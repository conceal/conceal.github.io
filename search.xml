<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>渝中召开领导干部大会 传达学习陈敏尔书记参加渝中代表团审议时的讲话精神</title>
      <link href="/2019/03/26/yu-zhong-zhao-kai-ling-dao-gan-bu-da-hui/"/>
      <url>/2019/03/26/yu-zhong-zhao-kai-ling-dao-gan-bu-da-hui/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/OHD6z6fDlM9822fpn79tIribC0iaaH1QkzDAX4klv2ePEm8FsXkiatrChPP3NnrjLmngQ88zL0YIJc9DqamF6icseA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt></p><blockquote><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2kfkimtj30u00gwkfp.jpg" alt><br>今（1）日，渝中召开领导干部大会，传达学习市委书记陈敏尔在参加渝中代表团审议时的讲话精神。渝中区委书记黄玉林出席会议并讲话，区委副书记、区长商奎，区人大常委会主任米绍林，区政协主席陈大奎，区委副书记何家利以及全体在家区级领导，全区正处级以上领导干部参加会议。</p></blockquote><blockquote><p>黄玉林指出，陈敏尔书记到渝中代表团参加审议，是对渝中工作的关心和厚爱，是对全区干部群众凝心聚力、砥砺奋进推进高质量发展、创造高品质生活的有力鞭策。全区上下一定要认真学习领会、深入贯彻落实陈敏尔书记参加渝中代表团审议时的讲话精神，全力以赴推动市委要求在渝中落实落地。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2l3w53ij30u00gw4hn.jpg" alt><br>黄玉林强调，要深刻领会把握陈敏尔书记关于“紧紧围绕习近平总书记对重庆提出的重要指示要求，进一步提高政治站位和战略站位，增强战略谋划力、战役执行力”的指示精神，把准方向保持定力，确保中央要求和市委部署率先在渝中落地生根、开花结果。要自觉维护习近平总书记党中央的核心、全党的核心地位，维护党中央权威和集中统一领导，牢固树立“四个意识”，坚定“四个自信”，以实际行动兑现市委“三个确保”的政治承诺。要深学笃用习近平新时代中国特色社会主义思想，把总书记对重庆的殷殷嘱托领会好，始终沿着总书记指引的方向前进。要按照陈敏尔书记“学在深处、谋在新处、干在实处、走在前列”要求，把总书记对重庆提出的“两点”定位、“两地”“两高”目标和营造良好政治生态、做到“四个扎实”的重要指示要求，落实为渝中行动，转化为实在成效。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2m4y131j30u00mi1kx.jpg" alt><br>黄玉林强调，要深刻领会把握陈敏尔书记关于“把构建现代产业体系作为城市发展的重要支撑”的指示要求，坚定方向突出重点，创新发展金融业，优化发展高端商贸业，融合发展文化旅游业，升级发展康养产业，用好优势医疗、教育资源，推动现代服务业创新升级发展。要深刻领会把握陈敏尔书记“大力推进社会治理现代化，贯彻以人民为中心的发展思想，让人民群众在城市生活更方便、更舒心、更美好”的指示要求，夯实基层强化基础，把安全放在城市管理服务第一位，增强城市管理服务的人文关怀，创新城市管理服务方式方法，全面提高城市管理服务水平。要深刻领会把握陈敏尔书记对渝中经济社会发展成绩的肯定，增强信心坚定决心，把市委市政府对渝中的肯定转化为发展的强大动力，牢记中心城区职责使命不动摇，顺应城市工作新形势、改革发展新要求、人民群众新期待，不断奋发有为、担当作为，着力打造适应服务业发展现代化和社会治理现代化要求的高素质干部队伍，凝聚起推动渝中高质量发展的强大合力。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼-View的事件体系</title>
      <link href="/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/"/>
      <url>/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/</url>
      
        <content type="html"><![CDATA[<p><strong>View是Android中的所有控件的基类，所有的控件都是直接或间接继承自View，所以View在Android中是一个很重要的概念。本篇将简要介绍View。<br>内容如下：</strong></p><ul><li>Android UI界面架构</li><li>View的基础知识</li><li>View的滑动</li><li>弹性滑动</li><li>View的事件分发机制</li><li>View的滑动冲突</li></ul><hr><h3 id="一、Android-UI界面架构"><a href="#一、Android-UI界面架构" class="headerlink" title="一、Android UI界面架构"></a>一、Android UI界面架构</h3><p>讲View之前先涉及一点Android的UI结构，后面的View分发机制会涉及一点这里的知识。<br>每个Activity包含一个<code>PhoneWindow</code>对象，<code>PhoneWindow</code>设置<code>DecorView</code>为应用的根视图（顶级视图）。在里面就是我们熟悉的<code>TitleView</code>和<code>ContentView</code>。<code>titleView</code>的位置就是我们那平常看到的App的标题栏，而我们平时在Activit中使用的<code>setContentView（）</code>就是设置<code>ContentView</code>。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrn2iri7j30ve0g0k2g.jpg" alt></p><h3 id="二、View的基础知识"><a href="#二、View的基础知识" class="headerlink" title="二、View的基础知识"></a>二、View的基础知识</h3><h4 id="1、什么是View"><a href="#1、什么是View" class="headerlink" title="1、什么是View"></a>1、什么是View</h4><p><strong>View：</strong>它是一种界面层的控价的一种抽象，它代表了一个控价。Android中的所有的控件都继承自它。<br><strong>ViewGroup：</strong>顾名思义这是一个View的组合，它内部包含了多个View。ViewGroup也继承了View，这就意味着View本身就可以是单个控件也可以是多个控价组成的一组控件。<br>从某种角度讲，Android中的控价可以分为两大类：View和ViewGroup。通过ViewGroup，整个界面可以组成一个View树，上层的View要负责下层View的测量与绘制，并传递事件。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrnrvi8aj30j60b3dj1.jpg" alt></p><h4 id="2、View的位置参数"><a href="#2、View的位置参数" class="headerlink" title="2、View的位置参数"></a>2、View的位置参数</h4><p>a. Android坐标系：以屏幕左上角为坐标原点，<strong>向右</strong>为x轴正方向，<strong>向下</strong>为y轴正方向。<br>b. View的位置主要由它的四个顶点决定：top、left、right、bottom</p><ul><li>top：左上角的纵坐标</li><li>left：左上角的横坐标</li><li>right：右下角的横坐标</li><li>bottom：右下角的纵坐标<br><strong>这些都是相对于View的父容器而言的，是一种相对坐标</strong><br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zro3hdndj30c50bkq42.jpg" alt><br>由上图就很容易的得到View的宽高和坐标的关系：<pre><code>width = right - leftheight = bottom - top</code></pre>我们了解了上述View属性，那我们怎么获取这些属性呢。别着急，其实View还提供了get方法帮助我们获取上述属性。</li><li>left = getLeft()</li><li>Right = getRight()</li><li>top = getTop()</li><li>bottom = getBottom</li><li>width = getWidth</li><li>height = getHeight</li></ul><p>c.从Android3.0开始，View增加了额外的几个参数：x、y、translationX、translationY。<br>其中x和y是View左上角的坐标，translationX和translationY是View的左上角相对于父容器的偏移量，他们的默认值均为0。和View的基本属性一样，这些参数也是相对于View父容器的，而且View也提供了set/get方法。</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zroc04s9j30kl0hd788.jpg" alt></p><blockquote><p>x = left + translationX<br>y = top + translationY</p></blockquote><p><strong>注意：</strong> View在移动的过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x、y、translationX和translationUY这四个参数。另外在onCreate()方法里面无法获取到View的坐标参数，这是因为此时的View还未开始绘制，全部的坐标参数都将是0。</p><h4 id="3-MotionEvent和TouchSlop"><a href="#3-MotionEvent和TouchSlop" class="headerlink" title="3. MotionEvent和TouchSlop"></a>3. MotionEvent和TouchSlop</h4><h5 id="1-MotionEvent"><a href="#1-MotionEvent" class="headerlink" title="1.MotionEvent"></a>1.MotionEvent</h5><p>在手指接触屏幕后所产生的一系列的事件，典型的事件类型有：</p><ul><li>ACTION_DOWN -—— 手指接触屏幕</li><li>ACTION_MOVE -—— 手指在屏幕上移动</li><li>ACTION_UP ———— 手指从屏幕上松开的一瞬间<br>正常情况下，一次手指接触屏幕的行为就会触发一系列的事件，列出两种典型情况：</li><li>点击屏幕后松开：ACTION_DOWN -&gt; ACTION_UP</li><li>点击屏幕后滑动一段距离松开：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_UP</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5494434-1fe5babc389caa90?imageMogr2/auto-orient/" alt></p><p><strong>在Android中所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、历史记录、第几个手指等，所以我们可以通过MotionEvent对象来得到点击事件的x和y坐标。为此系统提供了两组方法：getX/getY和getRawX/getRawY。</strong></p><ul><li>getX/getY: 返回相当于当前View左上角的坐标</li><li>getRawX/getRawY: 放回对于手机屏幕左上角的坐标 </li></ul><p>具体关系如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5494434-825bc5992190e5e8?imageMogr2/auto-orient/" alt></p><h5 id="2-TouchSlop"><a href="#2-TouchSlop" class="headerlink" title="2. TouchSlop"></a>2. TouchSlop</h5><p>TouchSlops是系统所能识别出来的滑动的最小的距离。即这是一个常量，当手机在屏幕上的滑动距离小于这个常量的时候，系统就不会认为这是一个滑动操作。这个常量和设备有关，在不同的设备上有不同的值，我们可以通过<code>ViewConfiguration.get(get(context)).getScaledTouchSlop()</code>获取到这个常量。</p><h4 id="4-VelocityTracker、GestureDetector和Scroller"><a href="#4-VelocityTracker、GestureDetector和Scroller" class="headerlink" title="4. VelocityTracker、GestureDetector和Scroller"></a>4. VelocityTracker、GestureDetector和Scroller</h4><h5 id="1-VelocityTracker"><a href="#1-VelocityTracker" class="headerlink" title="1. VelocityTracker"></a>1. VelocityTracker</h5><p>–速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。<br>使用过程：首先在View的<code>onTouchEvent</code>方法中追踪当前事件的速度：</p><pre><code>VelocityTracker mVelocityTracker = VelocityTracker.obtain();mVelocityTracker.addMovement(event);</code></pre><p>接着，在<strong>ACTION_MOVe</strong>事件中获取当前的速度：</p><pre><code>mVolocityTracker.computeCurrenVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity();float yXelocity = mVelocityTracker.getYVelocity();</code></pre><p>最后，当不需要使用它是，需要调用clear方法来重置并回收内存：</p><pre><code>mVelocityTracker.clear();mVelocityTracker.recycle();</code></pre><p><strong>注意这里计算的速度值为1000ms时间间隔移动的像素值，假设移动了100像素，速度就是100像素/秒</strong></p><h5 id="2-GestureDetector"><a href="#2-GestureDetector" class="headerlink" title="2. GestureDetector"></a>2. GestureDetector</h5><p>–手势检测。用于辅助检测用户的点击、滑动、长按、双击等行为。<br>使用过程：<br>创建一个<code>GestureDetector</code>对象并实现<code>onGestureLister</code>接口，根据需要是想点击方法：</p><pre><code>GestureDetector mGestureDetector = new GestureDetector(this);mGestureDetector.setIsLongpressEnabled(false);  //解决长按屏幕后无法实现拖动的现象</code></pre><p>接着，接管目标<code>View</code>的<code>onTouchEvent</code>方法，在待监听View的<code>onTouchEvent</code>方法中添加如下实现：</p><pre><code>boolean consume = mGestureDetector.onTouchEvent(event);return consume;</code></pre><p>做完上面两步我们就可以有选择的实现OnGestureListener和OnDoubleTapListener中的方法了,OnGestureListener和OnDoubleTapListener接口中的方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>所属接口</th></tr></thead><tbody><tr><td>onDown</td><td>手指轻轻接触屏幕的一瞬间，只有一个ACTION_DOWN</td><td>OnGestureListener</td></tr><tr><td>onShowPress</td><td>手指轻轻触摸屏幕，尚未松开或拖动， 由1个ACTION_DOWN触发</td><td>OnGestureListener</td></tr><tr><td>onSingleTopUp</td><td>手指（轻轻触摸屏幕后）松开，伴随着一个ACTION_UP触发（这是点击行为）</td><td>OnGestureListener</td></tr><tr><td>onScroll</td><td>手指按下屏幕并拖动，由1个ACTION_DOWN和多个ACTION_MOVE触发（这是拖动功能）</td><td>OnGestureListener</td></tr><tr><td>onLongPress</td><td>用户长按屏幕</td><td>OnGestureListener</td></tr><tr><td>onFling</td><td>用户触摸屏幕、快速的滑动后松开，由1个ACTION_DOWN、多个ACTION_MOVE和1个ACTION_UP触发，这是快速滑动行为</td><td>OnGestureListener</td></tr><tr><td>onDoubleTap</td><td>双击，由2个ACTION_DOWN触发，他不能和onSingleTapConfirmed共存</td><td>onDoubleTapListener</td></tr><tr><td>onSingleTapConfirmed</td><td>严格的点击行为</td><td>onDoubleTapListener</td></tr><tr><td>onDoubleTapEvent</td><td>表示发生了双击行为，在双击的期间，ACTION_DOWN、ACTION_MOVE、ACTION_UP都会触发次回调</td><td>onDoubleTapListener</td></tr></tbody></table><blockquote><p>在实际开发中可以不使用GestureDetector，完全可以自己在onTouchEvent中实现所需的监听。另外，如果知识监听滑动相关的，建议自己在onGestureDetector中实现，如果要监听双击这种行为的话，就使用GestureDetecter。</p></blockquote><h5 id="3-Scroller"><a href="#3-Scroller" class="headerlink" title="3. Scroller"></a>3. Scroller</h5><p>弹性滑动，用于实现View的弹性滑动。<br>当时使用scrollTo/scrollBy滑动时，滑动是瞬间完成的，这样的滑动效果看起来没有流畅感。这个时候就需要使用Scroller来实现由过渡效果的滑动。Scroller的话送不是瞬间完成的，它是在一定时间间隔内完成的。Scroller本身不能使View滑动，它需要配合View的computeScroll方法才能共同完成View的滑动。下面是一个简单的实现弹性滑动的代码：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();    int delta = destX - scrollX;    //1000ms内滑向destX，效果就是慢慢滑动    mScroller.startScroll(scrollX, 0, delta, 0, 1000);    invalidate();}@Overridepublic void computeScroll() {    if(mScroller.computeScrollOffSet()) {        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());        postInvalidate();    }}</code></pre><h3 id="三、View的滑动"><a href="#三、View的滑动" class="headerlink" title="三、View的滑动"></a>三、View的滑动</h3><blockquote><p><strong>实现View滑动的三种方式：</strong></p><ol><li>通过View本身提供的scrollTo/scrollBy方法</li><li>通过动画给View施加平移效果</li><li>通过改变View的LayoutParams使得View重新布局</li></ol></blockquote><h4 id="1-使用scrollTo-scrollBy"><a href="#1-使用scrollTo-scrollBy" class="headerlink" title="1. 使用scrollTo/scrollBy"></a>1. 使用scrollTo/scrollBy</h4><p>为了实现View的滑动，Vie提供了专门的方法实现这个功能：scrollTo和scrollBy<br><strong>scrollTo()</strong>:在当前视图内容偏移至(x , y)坐标处，即显示(可视)区域位于(x , y)坐标处。</p><pre><code>/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */    public void scrollTo(int x, int y) {        //偏移位置发生了改变        if (mScrollX != x || mScrollY != y) {              int oldX = mScrollX;            int oldY = mScrollY;            mScrollX = x;  //赋新值，保存当前便宜量            mScrollY = y;            //回调onScrollChanged方法            onScrollChanged(mScrollX, mScrollY, oldX, oldY);            if (!awakenScrollBars()) {                invalidate();  //一般都引起重绘            }        }    }</code></pre><p><strong>scrollBy():</strong>：在当前视图内容继续偏移(x , y)个单位，显示(可视)区域也跟着偏移(x,y)个单位。</p><pre><code> /**       * Move the scrolled position of your view. This will cause a call to       * {@link #onScrollChanged(int, int, int, int)} and the view will be       * invalidated.       * @param x the amount of pixels to scroll by horizontally       * @param y the amount of pixels to scroll by vertically       */      // 看出原因了吧 。。 mScrollX 与 mScrollY 代表我们当前偏移的位置 ， 在当前位置继续偏移(x ,y)个单位      public void scrollBy(int x, int y) {          scrollTo(mScrollX + x, mScrollY + y);      }</code></pre><p><strong>总结:scrollTo()指的是移动到制定的(x,y)位置，而scrollBy(x,y)指的是，在当前位置在移动(x,y)个位置</strong></p><p>mScrollX和mScrollY分别表示View在X、Y方向的滚动距离。mScrollX：View的左边缘减去View的内容的左边缘；mScrollY：View的上边缘减去View的内容的上边缘。从右向左滑动，mScrollX为正值，反之为负值；从下往上滑动，mScrollY为正值，反之为负值。（更直观感受：查看下一张照片或者查看长图时手指滑动方向为正）</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g10db9qbgdj30jg0dracq.jpg" alt></p><h4 id="2-使用动画"><a href="#2-使用动画" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p> 这节我们讲解如何使用动画来移动View，主要操作是View的<code>translationX</code>和<code>translationY</code>的属性,既可以采用传统的View动画，也可以采用属性动画（如果使用属性动画的话，为了能够兼容3.0以下的版本，需要采用开源动画<code>nineoldandroids</code>(<a href="http://nineoldandroids.com/）" target="_blank" rel="noopener">http://nineoldandroids.com/）</a><br> 采用View动画代码，如下所示。此动画可以在100ms内将一个View从原始位置向右下角移动100个像素。</p><pre><code> &lt;?xml veision=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:fillAfter=&quot;true&quot;    android:zAdjustment=&quot;normal&quot;&gt;    &lt;translate         android:duration=&quot;100&quot;        android:fromXDelta=&quot;0&quot;        android:fromYDelta=&quot;0&quot;        android:interpolator=&quot;@android:anim/linear_interpolator&quot;        android:toXDelata=&quot;100&quot;        android:toYDelata=&quot;100&quot;/&gt;&lt;/set&gt;</code></pre><p> 采用属性动画就更简单了：</p><pre><code> ObjectAnimator.ofFloat(targetView, &quot;translationX&quot;, 0, 100).setDuration(100).start();</code></pre><p>View动画是对View的影像的操作，他并不能真正改变View的参数，包括宽/高，并且如果希望动画移动后的状态保留还必须讲<code>fillAfter</code>属性设置为true。而属性动画并不存在上述的问题，但是在Android3.0以下就不能使用属性动画了。</p><h4 id="3-使用LayoutParams将一个View重新布局"><a href="#3-使用LayoutParams将一个View重新布局" class="headerlink" title="3.使用LayoutParams将一个View重新布局"></a>3.使用LayoutParams将一个View重新布局</h4><p>比如将一个View向右移动100像素，向右，只需要把它的marginLeft参数增大即可，代码见下：</p><pre><code>MarginLayoutParams params = (MarginLayoutParams) btn.getLayoutParams();params.leftMargin += 100;btn.requestLayout();// 请求重新对View进行measure、layout//或btn.setLayoutParams(params);</code></pre><h4 id="4、各种滑动方式的比较"><a href="#4、各种滑动方式的比较" class="headerlink" title="4、各种滑动方式的比较"></a>4、各种滑动方式的比较</h4><ul><li>scrollTo/scrollBy：操作简单适合对View内容的滑动</li><li>动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</li><li>LayoutParams：操作稍微复杂，适合于有交互的View</li></ul><h3 id="四、弹性滑动"><a href="#四、弹性滑动" class="headerlink" title="四、弹性滑动"></a>四、弹性滑动</h3><p>上一节讲了View的滑动，但是这种直接滑动效果实在是太差了，这里我们学习如何实现渐进式滑动。虽然实现的方法有很多，但是基本思想都是一样的：将一次滑动分成若干次小的滑动，并在一定时间内完成。这里介绍三种实现方式：Scroller、Handler#postDelayed以及Thread#sleep。</p><h4 id="1-Scroller"><a href="#1-Scroller" class="headerlink" title="1.Scroller"></a>1.Scroller</h4><blockquote><ul><li>与scrollTo/scrollBy不同：scrollTo/scrollBy过程是瞬间完成的，非平滑；而Scroller则有过渡滑动的效果。</li><li>注意：Scoller本身无法让View弹性滑动，它需要和View的computerScroller方法配合使用。</li></ul></blockquote><p>再看一次Scroller的经典使用方法：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();//View的左边缘到其内容左边缘的距离  int scrollY = getScrollY();//View的上边缘到其内容上边缘的距离  int deltaX = dstX - scrollX;//x方向滑动的位移量  int deltaY = dstY - scrollY;//y方向滑动的位移量  scroller.startScroll(scrollX, scrollY, deltaX, deltaY, 1000); //开始滑动  invalidate(); //刷新界面}@Override//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记public void computeScroll() {  if (scroller.computeScrollOffset()) {     scrollTo(scroller.getCurrX(), scroller.getCurY());    postInvalidate();//通过不断的重绘不断的调用computeScroll方法  }}</code></pre><p>工作原理：当我们构造一个Scroller对象并且调用他的startScroll方法时，Scroller内部其实什么也没有做，他只是保存了我们传递的几个参数，这几个参数从startScroll的源码里就能看出：</p><pre><code>public void startScroll(int startX,int startY,int dx,int dy,int duration){  mMode = SCROLL_MODE;  mFinished = false;  mDuration = duration;//滑动时间  mStartTime = AnimationUtils.currentAminationTimeMills();//开始时间  mStartX = startX;//滑动起点  mStartY = startY;//滑动起点  mFinalX = startX + dx;//滑动终点  mFinalY = startY + dy;//滑动终点  mDeltaX = dx;//滑动距离  mDeltaY = dy;//滑动距离  mDurationReciprocal = 1.0f / (float)mDuration; }</code></pre><blockquote><p><strong>具体过程：</strong>在MotionEvent.ACTION_UP事件触发时调用startScroll方法-&gt;马上调用invalidate/postInvalidate方法-&gt;会请求View重绘，导致View.draw方法被执行-&gt;会调用View.computeScroll方法，此方法是空实现，需要自己处理逻辑。具体逻辑是：先判断computeScrollOffset，若为true（表示滚动未结束），则执行scrollTo方法，它会再次调用postInvalidate，如此反复执行，直到返回值为false。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g110wgux3cj30vw0kq43j.jpg" alt></p><blockquote><p>Scroll的computeScrollOffset()根据时间的流逝动态计算一小段时间里View滑动的距离，并得到当前View位置，再通过scrollTo继续滑动。即把一次滑动拆分成无数次小距离滑动从而实现弹性滑动。</p></blockquote><h4 id="2-使用动画-1"><a href="#2-使用动画-1" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p>动画本身就是一种渐进的过程，因此通过动画来实现滑动天然就有一种弹性效果。</p><pre><code>ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start();//在100ms内使得View从原始位置向右平移100像素</code></pre><p>我们还可以利用动画的特性来实现一些动画无法实现的特效，还拿scrollTo来说,我们想模仿Scroller来实现View的弹性滑动。</p><pre><code>final int startX = 0;final int deltaY = 100;ValueAnimator animator = ValueAnimator.onInt(0, 1).setDuration(1000);animator.addUpdateListener(new AnimatorUpdateListener() {    @Override    public void onAnimatorUpdate(ValueAnimator animator) {        float fraction = animator.getAnimatedFraction();        mButton.scrollTo(startX+(int)(deltaX * fraction), 0);    }});animator.start();</code></pre><p>在上述代码中，动画的本质并没有作用在任何对象上，他只是在1000ms内完成了一个对象，真正起到滑动效果的是动画监听器的onAnimatorUpdate方法的scrollTo。利用这个特性，我们可以在动画的每一帧到来时获取动画完成比例，然后根据这个比例计算出当前View的滑动距离。</p><h4 id="3-使用延时策略"><a href="#3-使用延时策略" class="headerlink" title="3.使用延时策略"></a>3.使用延时策略</h4><blockquote><p>核心思想：通过发送一系列的延时信息从而达到一种渐进式的效果。使用Handler或View的postDelayed方法，也可以使用线程的sleep方法。</p></blockquote><ul><li>postDelayed：通过它在handleMessage内发送延时信息，然后在消息中进行View的滑动，如果接连不断的发送这种延时信息就可以完成弹性滑动的效果了。</li><li>sleep：通过while循环不断的滑动View和sleep，就可以实现弹性滑动效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 要点提炼——开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity生命周期</title>
      <link href="/2019/03/07/activity-sheng-ming-zhou-qi/"/>
      <url>/2019/03/07/activity-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-返回栈"><a href="#1-返回栈" class="headerlink" title="1.返回栈"></a>1.返回栈</h2><p>Android时使用任务（task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈。<br>栈是一种后进先出的数据结构。在默认情况下，每当我们启用一个新的活动时，这个活动就会放在返回栈的最顶层，当调用Back或finish（）时，返回栈的最顶层的活动就会出栈。<br><img src="http://upload-images.jianshu.io/upload_images/11542292-794b43f5902753c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-活动的状态"><a href="#2-活动的状态" class="headerlink" title="2.活动的状态"></a>2.活动的状态</h2><h3 id="每个活动在其生命周期里有4种状态。"><a href="#每个活动在其生命周期里有4种状态。" class="headerlink" title="每个活动在其生命周期里有4种状态。"></a>每个活动在其生命周期里有4种状态。</h3><ol><li>运行状态：当一个活动位于返回栈的栈顶时，这个活动就会处于运行状态。</li><li>暂停状态：当一个活动不在处于栈顶的位置，但仍然可见时，这个活动就进入了暂停状态。比如：后台、点击一个活动弹出弹框。</li><li>停止状态：当一个活动不在处于栈顶的位置，并且完全不可见时，就进入了停止状态。<br>4.销毁状态：当一个活动从返回栈移除后就变成了销毁状态</li></ol><h2 id="3-活动的生命周期"><a href="#3-活动的生命周期" class="headerlink" title="3.活动的生命周期"></a>3.活动的生命周期</h2><h3 id="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"><a href="#Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。" class="headerlink" title="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"></a>Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。</h3><h5 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h5><p>它在活动第一次被创建时调用，表示活动正在被创建，应该在这个方法中完成活动的初始化的操作。比如：setContentVie()加载布局、初始化Activity数据、绑定事件。</p><h5 id="2-onStart（）"><a href="#2-onStart（）" class="headerlink" title="2.onStart（）"></a>2.onStart（）</h5><p>这个方法在活动由不可见变为可见时调用，表示活动正在被启动，即将开始，其实这个时候我们通常都认为活动已经可见了，但是含没有在前台出现，所以我们看不见。</p><h5 id="3-onResume（）"><a href="#3-onResume（）" class="headerlink" title="3.onResume（）"></a>3.onResume（）</h5><p>这个方法在活动准备和用户进行交互时调用，表示Activity已经可以看见了 ，即：出现在前台，并开始活动了。</p><h5 id="4-onPause"><a href="#4-onPause" class="headerlink" title="4.onPause()"></a>4.onPause()</h5><p>这个方法在系统准备去启动或者恢复另一个活动的时候调用，表示活动正在停止过程中。这个方法紧接着就是onStop()方法，但是特殊情况下，如果这个时候我们快速的回到当前的Activity，那么onResume就会被调用，这种情况属于极端情况，一般情况下很难出现。这个时候可以做一些<strong>数据存储</strong>、<strong>停止动画等工作</strong>，但是不能太耗时，太耗时会影响Activity的显示。</p><h5 id="5-onStop"><a href="#5-onStop" class="headerlink" title="5.onStop"></a>5.onStop</h5><p>这个方法在活动完全不可见时调用。表示Activity即将停止。这个时候我们可以做些稍微重量级的工作，但是又不能太耗时。</p><h5 id="6-onRestart（）"><a href="#6-onRestart（）" class="headerlink" title="6.onRestart（）"></a>6.onRestart（）</h5><p>这个方法在活动由停止状态变成运行状态时调用，表示活动正在重新被启动。</p><h5 id="7-onDestroy"><a href="#7-onDestroy" class="headerlink" title="7.onDestroy()"></a>7.onDestroy()</h5><p>这个方法在活动被销毁之前调用，表示Activity即将被销毁，之后活动就将变成销毁状态。这是Activity生命周期中最后一个回调方法，在这里我们可以做一些<strong>回收工作</strong>和<strong>最终的资源释放</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/11542292-f156f9863d8994ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："><a href="#针对上图这里附加几个常见情况的Activity的生命周期的回调流程：" class="headerlink" title="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："></a>针对上图这里附加几个常见情况的Activity的生命周期的回调流程：</h5><ol><li>针对一个特定的Activity的第一次启动：回调流程：onCreate -&gt; onStart -&gt; onResume</li><li>当用户打开新的Activity或者切换到桌面的时候，.回调流程：onPause -&gt; onStop</li><li>当从Activity(A)跳转到Activity(B)时，回调流程：onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)</li><li>当用户回到原来的Activity时：回调流程：onRestart -&gt; onStart -&gt; onResume</li><li>当用户按back键回退时，回调流程：onPause -&gt; onStop -&gt; onDestory</li></ol><h2 id="4-活动的生存期"><a href="#4-活动的生存期" class="headerlink" title="4.活动的生存期"></a>4.活动的生存期</h2><p>1.完整生存期：活动的创建和销毁：onCreate（）和 onDestroy（）<br>2.可见生存期：活动是否可见：onStart（） 和 onStop（）<br>3.前台生存期：活动是否在前台：onResume（） 和 onPause（）</p><p><img src="media/15519727864455/15519766712395.jpg" alt></p><blockquote><p>问题1:onStart()、onStop() 与 onResume()、onPause()的区别。</p></blockquote><p>这两对生命回调方法看起来差不多，在使用时我们甚至可以只保留一对。他们唯一的不同就是：<br>onStart()、onStop()是从<strong>是否可见</strong>这个角度回调的；onResume()、onPause()是从<strong>是否位于前台</strong>这个角度回调的。</p><blockquote><p>问题2: 假设从ActivityA跳到ActivityB中去，那么ActivityB的onResume回调和ActivityA的onPause回调那个会先执行。</p></blockquote><p>这个问题我们要从Activity的启动流程的源码开始解释了。Activity启动过程的源码非常复杂，主要涉及了<strong>Instrumentation</strong>、<strong>ActivityThread</strong>(Android的主线程)和<strong>ActivityManagerService</strong>(AMS)。简单理解就是：启动一个Activity的请求会由Instrumentation来处理，然后将它通过Binder向AMS发送请求，AMS内部维护着一个ActivityStack(活动栈),并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期的调用。<br>源码这里我就不粘贴出来了，直接上流程吧：</p><ol><li>首先我们看到的是ActivityStack中的resumeTopActivityInnerLocked方法将栈顶的Activity先onPause,然后新Activity才能准备启动</li><li>ActivityStackSupervisor中的realStartActivityLocked()方法中调用app.thread.scheduleLaunchActivity方法，因为app.thread是主线程ActivityThread中的ApplicationThrea的一个实现，所以这个方法实在ActivityThread(主线程)中实现的。</li><li>scheduleLaunchActivity方法会在ActivityThread中调用handleLaunchActivity方法执行onCreate、onStart、onResume回调。</li><li>在handleLaunchActivity方法中会先执行performLaunchActivity方法创建一个Activity，同时调用onCreate和onStart。然后handleResumeActivity方法会执行新建的Activity的onResume回调。</li></ol><h2 id="5-onSaveInstanceState和onRestoreInstanceState"><a href="#5-onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="5.onSaveInstanceState和onRestoreInstanceState"></a>5.onSaveInstanceState和onRestoreInstanceState</h2><p>a.出现时机：Activity异常终止时<br>b.系统异常终止时，调用onSavaInstanceState来保存状态。该方法在onStop之前调用，但和onPause没有时序关系。<br>c.Activity被重新创建时，调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。</p><blockquote><p>onSaveInstanceState与onPause的区别：前者适用于对临时性状态的保存，而后者适用于对数据的持久化保存。</p></blockquote><blockquote><p>可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。<strong>谷歌推荐使用onRestoreInstanceState进行数据恢复</strong>。</p></blockquote><h2 id="6-异常情况下的生命周期分析"><a href="#6-异常情况下的生命周期分析" class="headerlink" title="6. 异常情况下的生命周期分析"></a>6. 异常情况下的生命周期分析</h2><h3 id="1）-资源相关系统配置发生改变导致Activity被杀死重新创建"><a href="#1）-资源相关系统配置发生改变导致Activity被杀死重新创建" class="headerlink" title="1）.资源相关系统配置发生改变导致Activity被杀死重新创建"></a>1）.资源相关系统配置发生改变导致Activity被杀死重新创建</h3><p><img src="media/15519727864455/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"><br>当系统配置发生改变之后，Activity会被销毁，其onPause、onStop、onDestory都会被调用，同时由于Activity是在异常情况下终止的，系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态(onSaveInstanceState调用实在onStop之前的，他和onPause没有固定的顺序关系，既可能在他前面也可能会在他后面)。当Activity被重新创建后，系统会调用<strong>onRestoreInstanceState</strong>方法，并把Activity销毁时<strong>onSaveInstanceState</strong>方法保存的<strong>Bundle对象</strong>作为<strong>参数</strong>同时传给<strong>onRestoreInstanceState方法和onCreate方法</strong>。但要注意onRestoreInstanceState在onStart之后调用。</p><blockquote><p>为了避免由于配置的改变导致Activity重建。可以在AndroidManifest.xml中对应的Activity中设置<code>android:configChanges</code>,然后重写onConfigurationChanged方法。 例如：<br><code>android:configChanges=&quot;orientation|screenSize&quot;</code>,这样在屏幕旋转时Activity就不会被杀死重建了，只会调用onConfigurationChanged方法。</p></blockquote><h3 id="2）-资源内存不足导致优先级较低的Activity被杀死"><a href="#2）-资源内存不足导致优先级较低的Activity被杀死" class="headerlink" title="2）.资源内存不足导致优先级较低的Activity被杀死"></a>2）.资源内存不足导致优先级较低的Activity被杀死</h3><h4 id="Activity的优先级由高到低可以分为如下："><a href="#Activity的优先级由高到低可以分为如下：" class="headerlink" title="Activity的优先级由高到低可以分为如下："></a>Activity的优先级由高到低可以分为如下：</h4><ol><li>前台Activity——正在和用户交互的Activity，优先级最高。</li><li>可见但非前台Activity—比如弹出一个弹窗，导致Activity仍可见但是无法和用户交互。</li><li>后台Activity-已经被暂停的Activity，比如执行了onStop，优先级最低</li></ol><p><strong>当系统内存不足时就会按照上面的优先级从低到高杀掉Activity所在的进程</strong><br><strong>若一个进程没有任意一个四大组件进行，进程也会被很快杀掉</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/07/hello-world/"/>
      <url>/2019/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
