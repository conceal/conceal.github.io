<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Activity生命周期</title>
      <link href="/2019/03/07/activity-sheng-ming-zhou-qi/"/>
      <url>/2019/03/07/activity-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-返回栈"><a href="#1-返回栈" class="headerlink" title="1.返回栈"></a>1.返回栈</h2><p>Android时使用任务（task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈。<br>栈是一种后进先出的数据结构。在默认情况下，每当我们启用一个新的活动时，这个活动就会放在返回栈的最顶层，当调用Back或finish（）时，返回栈的最顶层的活动就会出栈。<br><img src="http://upload-images.jianshu.io/upload_images/11542292-794b43f5902753c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-活动的状态"><a href="#2-活动的状态" class="headerlink" title="2.活动的状态"></a>2.活动的状态</h2><h3 id="每个活动在其生命周期里有4种状态。"><a href="#每个活动在其生命周期里有4种状态。" class="headerlink" title="每个活动在其生命周期里有4种状态。"></a>每个活动在其生命周期里有4种状态。</h3><ol><li>运行状态：当一个活动位于返回栈的栈顶时，这个活动就会处于运行状态。</li><li>暂停状态：当一个活动不在处于栈顶的位置，但仍然可见时，这个活动就进入了暂停状态。比如：后台、点击一个活动弹出弹框。</li><li>停止状态：当一个活动不在处于栈顶的位置，并且完全不可见时，就进入了停止状态。<br>4.销毁状态：当一个活动从返回栈移除后就变成了销毁状态</li></ol><h2 id="3-活动的生命周期"><a href="#3-活动的生命周期" class="headerlink" title="3.活动的生命周期"></a>3.活动的生命周期</h2><h3 id="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"><a href="#Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。" class="headerlink" title="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"></a>Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。</h3><h5 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h5><p>它在活动第一次被创建时调用，表示活动正在被创建，应该在这个方法中完成活动的初始化的操作。比如：setContentVie()加载布局、初始化Activity数据、绑定事件。</p><h5 id="2-onStart（）"><a href="#2-onStart（）" class="headerlink" title="2.onStart（）"></a>2.onStart（）</h5><p>这个方法在活动由不可见变为可见时调用，表示活动正在被启动，即将开始，其实这个时候我们通常都认为活动已经可见了，但是含没有在前台出现，所以我们看不见。</p><h5 id="3-onResume（）"><a href="#3-onResume（）" class="headerlink" title="3.onResume（）"></a>3.onResume（）</h5><p>这个方法在活动准备和用户进行交互时调用，表示Activity已经可以看见了 ，即：出现在前台，并开始活动了。</p><h5 id="4-onPause"><a href="#4-onPause" class="headerlink" title="4.onPause()"></a>4.onPause()</h5><p>这个方法在系统准备去启动或者恢复另一个活动的时候调用，表示活动正在停止过程中。这个方法紧接着就是onStop()方法，但是特殊情况下，如果这个时候我们快速的回到当前的Activity，那么onResume就会被调用，这种情况属于极端情况，一般情况下很难出现。这个时候可以做一些<strong>数据存储</strong>、<strong>停止动画等工作</strong>，但是不能太耗时，太耗时会影响Activity的显示。</p><h5 id="5-onStop"><a href="#5-onStop" class="headerlink" title="5.onStop"></a>5.onStop</h5><p>这个方法在活动完全不可见时调用。表示Activity即将停止。这个时候我们可以做些稍微重量级的工作，但是又不能太耗时。</p><h5 id="6-onRestart（）"><a href="#6-onRestart（）" class="headerlink" title="6.onRestart（）"></a>6.onRestart（）</h5><p>这个方法在活动由停止状态变成运行状态时调用，表示活动正在重新被启动。</p><h5 id="7-onDestroy"><a href="#7-onDestroy" class="headerlink" title="7.onDestroy()"></a>7.onDestroy()</h5><p>这个方法在活动被销毁之前调用，表示Activity即将被销毁，之后活动就将变成销毁状态。这是Activity生命周期中最后一个回调方法，在这里我们可以做一些<strong>回收工作</strong>和<strong>最终的资源释放</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/11542292-f156f9863d8994ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："><a href="#针对上图这里附加几个常见情况的Activity的生命周期的回调流程：" class="headerlink" title="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："></a>针对上图这里附加几个常见情况的Activity的生命周期的回调流程：</h5><ol><li>针对一个特定的Activity的第一次启动：回调流程：onCreate -&gt; onStart -&gt; onResume</li><li>当用户打开新的Activity或者切换到桌面的时候，.回调流程：onPause -&gt; onStop</li><li>当从Activity(A)跳转到Activity(B)时，回调流程：onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)</li><li>当用户回到原来的Activity时：回调流程：onRestart -&gt; onStart -&gt; onResume</li><li>当用户按back键回退时，回调流程：onPause -&gt; onStop -&gt; onDestory</li></ol><h2 id="4-活动的生存期"><a href="#4-活动的生存期" class="headerlink" title="4.活动的生存期"></a>4.活动的生存期</h2><p>1.完整生存期：活动的创建和销毁：onCreate（）和 onDestroy（）<br>2.可见生存期：活动是否可见：onStart（） 和 onStop（）<br>3.前台生存期：活动是否在前台：onResume（） 和 onPause（）</p><p><img src="media/15519727864455/15519766712395.jpg" alt></p><blockquote><p>问题1:onStart()、onStop() 与 onResume()、onPause()的区别。</p></blockquote><p>这两对生命回调方法看起来差不多，在使用时我们甚至可以只保留一对。他们唯一的不同就是：<br>onStart()、onStop()是从<strong>是否可见</strong>这个角度回调的；onResume()、onPause()是从<strong>是否位于前台</strong>这个角度回调的。</p><blockquote><p>问题2: 假设从ActivityA跳到ActivityB中去，那么ActivityB的onResume回调和ActivityA的onPause回调那个会先执行。</p></blockquote><p>这个问题我们要从Activity的启动流程的源码开始解释了。Activity启动过程的源码非常复杂，主要涉及了<strong>Instrumentation</strong>、<strong>ActivityThread</strong>(Android的主线程)和<strong>ActivityManagerService</strong>(AMS)。简单理解就是：启动一个Activity的请求会由Instrumentation来处理，然后将它通过Binder向AMS发送请求，AMS内部维护着一个ActivityStack(活动栈),并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期的调用。<br>源码这里我就不粘贴出来了，直接上流程吧：</p><ol><li>首先我们看到的是ActivityStack中的resumeTopActivityInnerLocked方法将栈顶的Activity先onPause,然后新Activity才能准备启动</li><li>ActivityStackSupervisor中的realStartActivityLocked()方法中调用app.thread.scheduleLaunchActivity方法，因为app.thread是主线程ActivityThread中的ApplicationThrea的一个实现，所以这个方法实在ActivityThread(主线程)中实现的。</li><li>scheduleLaunchActivity方法会在ActivityThread中调用handleLaunchActivity方法执行onCreate、onStart、onResume回调。</li><li>在handleLaunchActivity方法中会先执行performLaunchActivity方法创建一个Activity，同时调用onCreate和onStart。然后handleResumeActivity方法会执行新建的Activity的onResume回调。</li></ol><h2 id="5-onSaveInstanceState和onRestoreInstanceState"><a href="#5-onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="5.onSaveInstanceState和onRestoreInstanceState"></a>5.onSaveInstanceState和onRestoreInstanceState</h2><p>a.出现时机：Activity异常终止时<br>b.系统异常终止时，调用onSavaInstanceState来保存状态。该方法在onStop之前调用，但和onPause没有时序关系。<br>c.Activity被重新创建时，调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。</p><blockquote><p>onSaveInstanceState与onPause的区别：前者适用于对临时性状态的保存，而后者适用于对数据的持久化保存。</p></blockquote><blockquote><p>可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。<strong>谷歌推荐使用onRestoreInstanceState进行数据恢复</strong>。</p></blockquote><h2 id="6-异常情况下的生命周期分析"><a href="#6-异常情况下的生命周期分析" class="headerlink" title="6. 异常情况下的生命周期分析"></a>6. 异常情况下的生命周期分析</h2><h3 id="1）-资源相关系统配置发生改变导致Activity被杀死重新创建"><a href="#1）-资源相关系统配置发生改变导致Activity被杀死重新创建" class="headerlink" title="1）.资源相关系统配置发生改变导致Activity被杀死重新创建"></a>1）.资源相关系统配置发生改变导致Activity被杀死重新创建</h3><p><img src="media/15519727864455/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"><br>当系统配置发生改变之后，Activity会被销毁，其onPause、onStop、onDestory都会被调用，同时由于Activity是在异常情况下终止的，系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态(onSaveInstanceState调用实在onStop之前的，他和onPause没有固定的顺序关系，既可能在他前面也可能会在他后面)。当Activity被重新创建后，系统会调用<strong>onRestoreInstanceState</strong>方法，并把Activity销毁时<strong>onSaveInstanceState</strong>方法保存的<strong>Bundle对象</strong>作为<strong>参数</strong>同时传给<strong>onRestoreInstanceState方法和onCreate方法</strong>。但要注意onRestoreInstanceState在onStart之后调用。</p><blockquote><p>为了避免由于配置的改变导致Activity重建。可以在AndroidManifest.xml中对应的Activity中设置<code>android:configChanges</code>,然后重写onConfigurationChanged方法。 例如：<br><code>android:configChanges=&quot;orientation|screenSize&quot;</code>,这样在屏幕旋转时Activity就不会被杀死重建了，只会调用onConfigurationChanged方法。</p></blockquote><h3 id="2）-资源内存不足导致优先级较低的Activity被杀死"><a href="#2）-资源内存不足导致优先级较低的Activity被杀死" class="headerlink" title="2）.资源内存不足导致优先级较低的Activity被杀死"></a>2）.资源内存不足导致优先级较低的Activity被杀死</h3><h4 id="Activity的优先级由高到低可以分为如下："><a href="#Activity的优先级由高到低可以分为如下：" class="headerlink" title="Activity的优先级由高到低可以分为如下："></a>Activity的优先级由高到低可以分为如下：</h4><ol><li>前台Activity——正在和用户交互的Activity，优先级最高。</li><li>可见但非前台Activity—比如弹出一个弹窗，导致Activity仍可见但是无法和用户交互。</li><li>后台Activity-已经被暂停的Activity，比如执行了onStop，优先级最低</li></ol><p><strong>当系统内存不足时就会按照上面的优先级从低到高杀掉Activity所在的进程</strong><br><strong>若一个进程没有任意一个四大组件进行，进程也会被很快杀掉</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/07/hello-world/"/>
      <url>/2019/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ViewPage深入解析（一）</title>
      <link href="/2019/03/05/15517997196480/"/>
      <url>/2019/03/05/15517997196480/</url>
      
        <content type="html"><![CDATA[<p>话说小伙伴们在使用App的时候有没有注意到很多App的首页都是可以左右滑动的页面呢？很多App还有绚丽的轮播图广告。那么如何实现这样的效果呢？相信很多小伙伴都知道可以用ViewPager来完成！不过也许很多小伙伴也跟皮卡丘一样，虽然一直在使用ViewPager，但是大部分时间都是在ctrl+c、ctrl+v<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](http://upload-images.jianshu.io/upload_images/11542292-b4edb4549f2e6926.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &quot;【Android】ViewPager深入解析（一）_&quot;)</span><br><span class="line"></span><br><span class="line">但是，很多小伙伴也许并没有详细地了解过ViewPager，所谓“知其然知其所以然”，那么今天皮卡丘就和大家一起来学习下ViewPager吧</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个小标题后面的句子，素材来自于一款网络游戏，大家随便看看就可以了，跟主题无关，我只是觉得好玩......</span><br></pre></td></tr></table></figure><p><strong>1、江湖相逢</strong></p><blockquote><p><em>犹记与你初逢扬州湖畔，你只回眸一笑，我却惊艳了时光。</em></p></blockquote><p>关于ViewPager，我们先来看看api中的继承关系<br><img src="http://upload-images.jianshu.io/upload_images/11542292-0e43019e53da59aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="【Android】ViewPager深入解析（一）_"></p><p>从图里可以看出，ViewPager继承自ViewGroup，也就是ViewPager是一个容器类，可以包含其他的View类。然后我们在看看api中的定义：</p><blockquote><p>Layout manager that allows the user to flip left and right through pages of data. You supply an implementation of a PagerAdapter to generate the pages that the view shows.</p><p>Note this class is currently under early design and development. The API will likely change in later updates of the compatibility library, requiring changes to the source code of apps when they are compiled against the newer version.</p><p>ViewPager is most often used in conjunction with Fragment, which is a convenient way to supply and manage the lifecycle of each page. There are standard adapters implemented for using fragments with the ViewPager, which cover the most common use cases. These are FragmentPagerAdapter and FragmentStatePagerAdapter; each of these classes have simple code showing how to build a full user interface with them.</p></blockquote><p>有一些英语没有学好的小伙伴可能不是很能理解这一段描述。快去跟你们的英语老师道歉啊！嘛，这里皮卡丘就先给你们进行一下翻译吧，不过因为水平有限，可能会有一些翻译错误，如果大家发现错误的话欢迎留言哦。</p><blockquote><p>ViewPager是一个允许使用者左右滑动数据页面的布局管理器。你可以通过一个适配器（PagerAdapter）来管理要显示的页面。</p><p>不过要注意的是，这个类目前还处于初期的设计和开发。随着今后兼容库的更新，API文档也会进行更改，同时应用程序在编译时也需要对代码进行一定的修改。</p><p>ViewPager更多的时候会与Fragment一起使用，这是一种很好的方法来管理各个页面的生命周期。Android提供了一些专门的适配器来让ViewPager与Fragment一起工作，也就是FragmentPagerAdapter与FragmentStatePagerAdapter。他们基本上可以满足大部分常见的永续需求，并且他们都有简单的代码样例来展示如何用他们来建立一个完整的用户页面。</p></blockquote><p>通过这一段描述，大家应该对ViewPager有了一个大致的了解，皮卡丘大致把常用的信息再总结一下：</p><blockquote><p>1、ViewPager主要用来左右滑动。（类似图片轮播）<br>2、ViewPager要用适配器来连接“视图”和“数据”。（大家可以联想下listview的使用方法，原理是类似的）<br>3、官方推荐ViewPager与Fragment一起使用，并且有专门的适配器。</p></blockquote><p>好啦，看到这里，小伙伴们是不是对这么一个神奇的组件充满了兴趣呢？那我们赶紧来写一个最简单的ViewPager吧。</p><p><strong>2、相见恨晚</strong></p><blockquote><p><em>大家都说我逍遥此身君子意，但与你把酒言欢之时，我却知道，逍遥的心亦有了牵挂。所谓相见恨晚，大概就是如此吧。</em></p></blockquote><p>在创建项目之前，我们先大致来描述下该项目的功能：viewpager中包含3个视图，并且这3个视图可以通过左右滑动来进行切换。很简便吧？我们先创建一个ViewPagerDemo的工程。<br>既然我们需要包含3个视图，我们就先准备3个页面的布局吧（很简单的布局，就是居中显示一个图片）：<br>page1.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView </span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:src=&quot;@drawable/view1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>page2.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView </span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:src=&quot;@drawable/view2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>page3.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView </span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:src=&quot;@drawable/view3&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>然后是我们的主页面布局，只有一个ViewPager： activity_main.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">     &gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line">        android:id=&quot;@+id/myViewPager&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        &gt;&lt;/android.support.v4.view.ViewPager&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，ViewPager引入的时候必须写完整android.support.v4.view.ViewPager，如果我们按照一般控件那样直接写ViewPager，就会报以下的错误<br><img src="http://upload-images.jianshu.io/upload_images/11542292-6898ed24b20d5dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述" title="【Android】ViewPager深入解析（一）_"></p><p>其实从报错描述中我们大致能看出来是因为无法在android.view下面找到ViewPager这个类，这里的具体原因涉及到兼容包的问题，如果有机会的话皮卡丘也会以后再分享，不过这篇文章就先不深入研究啦。</p><p>好啦，我们已经把该准备的布局文件都准备好了，接下来我们开始来敲代码。<br>从API中我们看出来，viewpager是通过适配器来进行管理的（数据源—适配器—视图）。我们分别来看看：<br><strong>数据源：</strong>这里的数据比较简单，就是包含3个View的一个list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private View page1, page2, page3; // ViewPager包含的页面</span><br><span class="line">private List&lt;View&gt; pageList; // ViewPager包含的页面列表，一般给adapter传的是一个list</span><br><span class="line"></span><br><span class="line">MainActivity.java</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">LayoutInflater inflater = getLayoutInflater();</span><br><span class="line">page1 = inflater.inflate(R.layout.page1, null);</span><br><span class="line">page2 = inflater.inflate(R.layout.page2, null);</span><br><span class="line">page3 = inflater.inflate(R.layout.page3, null);</span><br><span class="line"></span><br><span class="line">pageList = new ArrayList&lt;View&gt;();</span><br><span class="line">pageList.add(page1);</span><br><span class="line">pageList.add(page2);</span><br><span class="line">pageList.add(page3);</span><br></pre></td></tr></table></figure><p><strong>视图：</strong>一般视图都是比较简单的，这里也不例外，就是一个ViewPager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private ViewPager myViewPager; // 要使用的ViewPager</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">myViewPager = (ViewPager) findViewById(R.id.myViewPager);</span><br></pre></td></tr></table></figure><p><strong>适配器：</strong>在大多数使用适配器的控件里，适配器相对于数据源和视图来说都更加复杂，同时也决定了这个控件主要的功能。ViewPager也不例外，所以我们有必要对PagerAdapter深入了解一下。<br>我们先来看看API中对PagerAdapter的描述：</p><blockquote><p>Base class providing the adapter to populate pages inside of a ViewPager. You will most likely want to use a more specific implementation of this, such as FragmentPagerAdapter or FragmentStatePagerAdapter.</p><p>When you implement a PagerAdapter, you must override the following methods at minimum:</p><ul><li>instantiateItem(ViewGroup, int)<ul><li>destroyItem(ViewGroup, int, Object)</li><li>getCount()</li><li>isViewFromObject(View, Object)</li></ul></li></ul><p>PagerAdapter is more general than the adapters used for AdapterViews. Instead of providing a View recycling mechanism directly ViewPager uses callbacks to indicate the steps taken during an update. A PagerAdapter may implement a form of View recycling if desired or use a more sophisticated method of managing page Views such as Fragment transactions where each page is represented by its own Fragment.</p><p>ViewPager associates each page with a key Object instead of working with Views directly. This key is used to track and uniquely identify a given page independent of its position in the adapter. A call to the PagerAdapter method startUpdate(ViewGroup) indicates that the contents of the ViewPager are about to change. One or more calls to instantiateItem(ViewGroup, int) and/or destroyItem(ViewGroup, int, Object) will follow, and the end of an update will be signaled by a call to finishUpdate(ViewGroup). By the time finishUpdate returns the views associated with the key objects returned by instantiateItem should be added to the parent ViewGroup passed to these methods and the views associated with the keys passed to destroyItem should be removed. The method isViewFromObject(View, Object) identifies whether a page View is associated with a given key object.</p><p>A very simple PagerAdapter may choose to use the page Views themselves as key objects, returning them from instantiateItem(ViewGroup, int) after creation and adding them to the parent ViewGroup. A matching destroyItem(ViewGroup, int, Object) implementation would remove the View from the parent ViewGroup and isViewFromObject(View, Object) could be implemented as return view == object;.</p><p>PagerAdapter supports data set changes. Data set changes must occur on the main thread and must end with a call to notifyDataSetChanged() similar to AdapterView adapters derived from BaseAdapter. A data set change may involve pages being added, removed, or changing position. The ViewPager will keep the current page active provided the adapter implements the method getItemPosition(Object).</p></blockquote><p>又到了皮卡丘的英语小讲堂啦，依然是大致的翻译：</p><blockquote><p>PagerAdapter是用于“将多个页面填充到ViewPager”的适配器的一个基类，大多数情况下，你们可能更倾向于使用一个实现了PagerAdapter并且更加具体的适配器，例如FragmentPagerAdapter或者FragmentStatePagerAdapter。</p><p>当你实现一个PagerAdapter时，你至少需要重写下面的几个方法：</p><ul><li>instantiateItem(ViewGroup, int)<ul><li>destroyItem(ViewGroup, int, Object)</li><li>getCount()</li><li>isViewFromObject(View, Object)</li></ul></li></ul><p>PagerAdapter比很多AdapterView的适配器更加通用。ViewPager使用回调机制来显示一个更新步骤，而不是直接使用视图回收机制。如果需要时，PagerAdapter也可以实现视图回收方法，或者直接使用一种更加巧妙的方法来管理页面，比如直接使用能够管理自身事务的Fragment。</p><p>ViewPager并不直接管理页面，而是通过一个key将每个页面联系起来。这个key用来跟踪和唯一标识一个给定的页面，且该key独立于adapter之外。PagerAdapter中的startUpdate(ViewGroup)方法一旦被执行，就说明ViewPager的内容即将开始改变。紧接着，instantiateItem(ViewGroup, int)和/或destroyItem(ViewGroup, int, Object)方法将会被执行，然后finishUpdate(ViewGroup)的执行就意味着这一次刷新的完成。当finishUpdate(ViewGroup)方法执行完时，与instantiateItem(ViewGroup, int)方法返回的key相对应的视图将会被加入到父ViewGroup中，而与传递给destroyItem(ViewGroup, int, Object)方法的key相对应的视图将会被移除。isViewFromObject(View, Object)方法则判断一个视图是否与一个给定的key相对应。</p><p>一个简单的PagerAdapter会选择将视图本身作为key，在将视图创建并加入父ViewGroup之后通过instantiateItem(ViewGroup, int)返回。这种情况下，destroyItem(ViewGroup, int, Object) 的实现方法只需要将View从ViewGroup中移除即可，而isViewFromObject(View, Object)的实现方法可以直接写成return view == object;。</p><p>PagerAdapter支持数据集的改变。数据集的改变必须放在主线程中，并且在结束时调用notifyDataSetChanged()方法，这与通过BaseAdapter适配的AdapterView类似。一个数据集的改变包含了页面的添加、移除或者位移。ViewPager可以通过在适配器中实现getItemPosition(Object)方法来保持当前页面处于运行状态。</p></blockquote><p>呼，看完了这一段描述，小伙伴们是不是有点累了呢<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; *   instantiateItem(ViewGroup, int)负责初始化指定位置的页面，并且需要返回当前页面本身（其实不一定要View本身，只要是能唯一标识该页面的key都可以，不过初学者一般就先用View本身作为key就可以啦）；</span><br><span class="line">&gt; *   destroyItem(ViewGroup, int, Object)负责移除指定位置的页面；</span><br><span class="line">&gt; *   isViewFromObject(View, Object)里直接写“return view == object;”即可（当然，如果你在instantiateItem(ViewGroup, int)里返回的不是View本身，那就不能这么写哦）；</span><br><span class="line">&gt; *   在描述中并未提及到getCount()方法，不过这个比较简单，也很常见，就是返回要展示的页面数量。</span><br><span class="line"></span><br><span class="line">看了这么多理论知识，小伙伴们有没有想立刻动手写一下代码呢？于是我们回到刚才的项目，开始写一个适配器。我们新建一个类MyPagerAdapter。</span><br><span class="line"></span><br><span class="line">MyPagerAdapter.java</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">package com.example.viewpagerdemo;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import android.support.v4.view.PagerAdapter;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line">public class MyPagerAdapter extends PagerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;View&gt; pageList;</span><br><span class="line"></span><br><span class="line">    public MyPagerAdapter(List&lt;View&gt; pageList) &#123;</span><br><span class="line">        this.pageList = pageList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">        // 返回要展示的图片数量</span><br><span class="line">        return pageList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isViewFromObject(View arg0, Object arg1) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">        // 刚开始用viewpager就直接写“return arg0 == arg1;”就好啦</span><br><span class="line">        return arg0 == arg1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroyItem(ViewGroup container, int position, Object object) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">        // 将当前位置的View移除</span><br><span class="line">        container.removeView(pageList.get(position));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">结合之前的翻译，相信小伙伴们都能比较好地理解这一段代码吧。接下来就简单了，和所有的适配器一样，将viewpager与适配器绑定就可以了。</span><br><span class="line"></span><br><span class="line">MainActivity.java</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">private MyPagerAdapter myPagerAdapter; // 适配器</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">myPagerAdapter = new MyPagerAdapter(pageList);</span><br><span class="line">myViewPager.setAdapter(myPagerAdapter);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">好啦，是时候运行程序了，我们来看看效果吧</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/11542292-8aea98b99e726681.gif?imageMogr2/auto-orient/strip" alt="图片描述" title="【Android】ViewPager深入解析（一）_"></p><p>哈哈哈哈哈哈哈哈哈哈是不是很好玩，当然篇幅所限，这只是ViewPager最最简单的功能，接下来皮卡丘还会继续写ViewPager的一些更高级的用法，欢迎小伙伴们继续支持<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![图片描述](http://upload-images.jianshu.io/upload_images/11542292-abc58b0a8d87668b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 &quot;【Android】ViewPager深入解析（一）_&quot;)</span><br><span class="line"></span><br><span class="line">皮卡~皮卡丘</span><br></pre></td></tr></table></figure></p><hr><p>接下来贴出本次demo的完整代码（慕课网暂时不能上传压缩包，所以先把代码都贴在文章里啦，不过其实建议是不要看demo，直接按照文章自己敲是最好哒） MainActivity.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.example.viewpagerdemo;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.support.v4.view.ViewPager;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private ViewPager myViewPager; // 要使用的ViewPager</span><br><span class="line"></span><br><span class="line">    private View page1, page2, page3; // ViewPager包含的页面</span><br><span class="line"></span><br><span class="line">    private List&lt;View&gt; pageList; // ViewPager包含的页面列表，一般给adapter传的是一个list</span><br><span class="line"></span><br><span class="line">    private MyPagerAdapter myPagerAdapter; // 适配器</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        myViewPager = (ViewPager) findViewById(R.id.myViewPager);</span><br><span class="line"></span><br><span class="line">        LayoutInflater inflater = getLayoutInflater();</span><br><span class="line">        page1 = inflater.inflate(R.layout.page1, null);</span><br><span class="line">        page2 = inflater.inflate(R.layout.page2, null);</span><br><span class="line">        page3 = inflater.inflate(R.layout.page3, null);</span><br><span class="line"></span><br><span class="line">        pageList = new ArrayList&lt;View&gt;();</span><br><span class="line">        pageList.add(page1);</span><br><span class="line">        pageList.add(page2);</span><br><span class="line">        pageList.add(page3);</span><br><span class="line"></span><br><span class="line">        myPagerAdapter = new MyPagerAdapter(pageList);</span><br><span class="line">        myViewPager.setAdapter(myPagerAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的完整代码都已经在文章中有，这里就不再另外贴了，至于@drawable/view1，@drawable/view2，@drawable/view3，就麻烦小伙伴们自己准备3张图片吧~~~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
