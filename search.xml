<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>要点提炼——Java  I/O流</title>
      <link href="/2019/04/16/yao-dian-ti-lian-java-i-o-liu/"/>
      <url>/2019/04/16/yao-dian-ti-lian-java-i-o-liu/</url>
      
        <content type="html"><![CDATA[<p><strong>这篇文章有点长，但是内容很丰富，IO知识也比较全，相信如果你能仔细读完一定会有所收获。</strong></p><blockquote><p>JavaIO操作的主要功能就是使用Java进行输入输出操作，Java中所有的所有操作类都存放在java.io包中，需要时倒入包。</p></blockquote><p>在整个java.io包中最重要的就是5个类和一个接口。5个类指File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。<br><img src="https://ws1.sinaimg.cn/large/0077HGE3ly1g24bbyylwyj313014cjve.jpg" alt></p><h2 id="一-文件操作类——File"><a href="#一-文件操作类——File" class="headerlink" title="一. 文件操作类——File"></a>一. 文件操作类——File</h2><table><thead><tr><th>序号</th><th>方法或常量</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public static final String pathSeparator</td><td>常量</td><td>表示路径的分隔符（windows是：“；”）</td></tr><tr><td>2</td><td>public static final separator</td><td>常量</td><td>表示路径的分隔符（windows是：“\”）</td></tr><tr><td>3</td><td>public File(String pathname)</td><td>构造</td><td>创建File类对象，传入完整的对象</td></tr><tr><td>4</td><td>public boolean createNewFile() throws IOException)</td><td>普通</td><td>创建新文件</td></tr><tr><td>5</td><td>public boolean delete()</td><td>普通</td><td>删除文件</td></tr><tr><td>6</td><td>public boolean exists()</td><td>普通</td><td>判断文件是否存在</td></tr><tr><td>7</td><td>public boolean isDirectory()</td><td>普通</td><td>判断给的路径是否是一个目录</td></tr><tr><td>8</td><td>public long length()</td><td>普通</td><td>返回文件的大小</td></tr><tr><td>9</td><td>public String[] list()</td><td>普通</td><td>列出指定目录的全部内容，只是列出了名称</td></tr><tr><td>10</td><td>public File[] list</td><td>普通</td><td>列出指定目录的全部内容，会列出路径</td></tr><tr><td>11</td><td>public boolean mkdir()</td><td>普通</td><td>创建一个目录</td></tr><tr><td>12</td><td>public boolean renameTo(File dest)</td><td>普通</td><td>为已有的文件重新命名</td></tr></tbody></table><pre><code>import java.io.File;import java.io.IOException;import static jdk.nashorn.internal.runtime.regexp.joni.Config.log;public class main {    public static void main(String[] args) {        File file = new File(&quot;/Users/syz/Documents&quot; + File.separator);        if (file.isDirectory()) {   //判断file对象是否是一个目录            File f = new File(&quot;/Users/syz/Documents&quot; + File.separator + &quot;test.txt&quot;);  //创建一个File类对象            if (f.exists()) {       //判断f文件是否存在                f.delete();         //删除文件            } else {                try {                    f.createNewFile();  //创建文件                    System.out.println(&quot;创建test.txt文件&quot;);                } catch (IOException e) {                    e.printStackTrace();                }            }            String[] str = file.list();      //列出指定目录的全部内容，只是列出了名称            for (int i = 0; i &lt; str.length; i++ ) {                System.out.println(str[i]);            }            File[] files = file.listFiles();   //列出指定目录的全部内容，会列出路径            for (int i = 0; i &lt; files.length; i++) {                System.out.println(files[i]);            }        } else {            file.mkdir();     //创建这个目录        }    }}</code></pre><p><strong>我们在使用new File(String pathname)方法时，只是得到了一个File类的对象，这个对象可以是一个文件或目录；然后我们需要使用exists()或idDirectory()判断这个文件或者目录是否存在，如果不存在，我们就需要使用createNewFile()或mkdir()创建一个文件或目录。</strong></p><h2 id="二-RandomAccessFile类"><a href="#二-RandomAccessFile类" class="headerlink" title="二. RandomAccessFile类"></a>二. RandomAccessFile类</h2><blockquote><p>如果要对文件的内容进行操作，则可以使用RandomAccessFile类进行，此类是一个随机类，可以随机读取一个文件中指定位置的数据。</p></blockquote><h4 id="RandomAccessFile类的常用操作方法"><a href="#RandomAccessFile类的常用操作方法" class="headerlink" title="RandomAccessFile类的常用操作方法"></a>RandomAccessFile类的常用操作方法</h4><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public RandomAccessFile(File file, String mode) throws FileNotFoundException</td><td>构造</td><td>接收一个File类的对象，指定操作路径；但是在设置时需要设置模式：r：只读；w：只写； rw：读写。</td></tr><tr><td>2</td><td>public RandomAccessFile(String name, String mode) throws FileNotFoundException</td><td>构造</td><td>直接接收一个文件路径，也需要设置模式</td></tr><tr><td>3</td><td>public void close()</td><td>普通</td><td>关闭操作</td></tr><tr><td>4</td><td>public int read(byte[] b)throws IOException</td><td>普通</td><td>将内容读取到一个byte[]数组中</td></tr><tr><td>5</td><td>public final byte readByte() throws IOException</td><td>普通</td><td>只读取一个字节</td></tr><tr><td>6</td><td>public final int readInt() throws IOException</td><td>普通</td><td>从文件中读取整型数据</td></tr><tr><td>7</td><td>public void seek(long pos) throws IOException</td><td>普通</td><td>设置读指针的位置</td></tr><tr><td>8</td><td>public final void writeByte(String s) throws IOException</td><td>普通</td><td>将一个字符串写入到文件中，按字节方式处理</td></tr><tr><td>9</td><td>public final void writeInt(int v) throws IOException</td><td>普通</td><td>将一个int整型的数字写入文件， 长度为4个单位</td></tr><tr><td>10</td><td>public int skipBytes(int n) throws IOException</td><td>普通</td><td>指针跳过指定的字节</td></tr></tbody></table><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><pre><code>import java.io.File;import java.io.RandomAccessFile;public class main {    public static void main(String[] args) throws Exception{        File file = new File(&quot;/Users/syz/Documents&quot; + File.separator + &quot;test.txt&quot;);        if (file.exists()) {            read(file);        } else {            write(file) ;        }    }    private static void read(File file) throws Exception{        RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;);        String name = null;        int age = 0;        byte[] b = new byte[8];   //准备空间读取姓名        raf.skipBytes(12);     //跳过第一个人的信息        for (int i = 0; i&lt;b.length; i++) {            b[i] = raf.readByte();      //读取一个字节到byte[]数组中        }        name = new String(b);           //将读取出来的byte[]数组变成String        age = raf.readInt();            //读取数字        System.out.println(&quot;第二个人的信息--&gt; 姓名：&quot; + name + &quot;； 年龄&quot; + age);        raf.seek(0);      //指针回到文件的开头        b = new byte[8];        for (int i = 0; i&lt;b.length; i++) {            b[i] = raf.readByte();        }        name = new String(b);        age = raf.readInt();        System.out.println(&quot;第一个人的信息--&gt; 姓名：&quot; + name + &quot;； 年龄&quot; + age);    }    private static void write(File file) throws Exception {    //需要抛出异常        RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);        String name = null;        int age = 0;        name = &quot;zhangsan&quot;;        age =  30;        raf.writeBytes(name);     //将name写入文件        raf.writeInt(age);        //将age写入文件        name = &quot;lisi    &quot;;        age = 50;        raf.writeBytes(name);            raf.writeInt(age);        raf.close();    }}</code></pre><p><strong>我们在使用指针跳跃字节时，我们统一设置的name为8个字节，age为4个字节，当然我们也可以genju自己的需求来设定变量的字节长度。</strong></p><h2 id="三-字节流与字符流"><a href="#三-字节流与字符流" class="headerlink" title="三. 字节流与字符流"></a>三. 字节流与字符流</h2><p>在程序中所有的数据都是以流的方式进行存储的。<strong>流</strong>是一组有顺序的、有起点和终点的字节集合，是对数据传输的总称和抽象。所以<strong>流</strong>的本质是<strong>数据传输</strong>。<br>程序需要数据时要使用输入流读取数据，将存储（文件）中的数据输入到程序中；当程序需要将数据保存起来的时候需要输出流，将程序的数据输出到存储（文件）中。<br>在java.io包中流的操作主要有<strong>字节流</strong>和<strong>字符流</strong>两类。两类都有输入和输出操作。在字节流中输出数据主要食用<strong>OutputScream</strong>类完成，输入数据主要由<strong>InputScream</strong>类完成。在字符流中输出数据主要使用<strong>Writer</strong>类完成，输入数据主要使用<strong>Reader</strong>完成。</p><blockquote><p>在javaIO中，文本操作的主要步骤为：</p><ol><li>使用File类打开一个文件</li><li>通过字节流或字符流的子类指定输出位置。</li><li>进行读写操作</li><li>关闭输入/输出流</li></ol></blockquote><h3 id="1、字节流"><a href="#1、字节流" class="headerlink" title="1、字节流"></a>1、字节流</h3><p><img src="media/15518464643263/15518477358341.jpg" alt><br>字节流主要操作byte类型数据，主要的操作类为OutputScream类和InputScream类。</p><h4 id="字节输出流：OutputScream"><a href="#字节输出流：OutputScream" class="headerlink" title="字节输出流：OutputScream"></a>字节输出流：OutputScream</h4><p>OutputScream是整个IO中字节输出流的最大父类，此类的定义如下：<br><code>public abstract class OutputScream extends Object implments Closeable, Flushable</code><br>从以上定义可以发现OutputScream是一个抽象类，如果要使用该类必须通过子类实例化。这个子类就是FileOutputScream类，通过向上转型化为OutputScream的实例化。FileOutputScream类的构造方法为：<br><code>public FileOutputScream(File file) throws FileNotFoundException</code><br>操作时必须接收一个File类的实例，且指明要输出的文件。</p><p>OutputScream的主要使用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public void close() throws Exception</td><td>普通</td><td>关闭输出流</td></tr><tr><td>2</td><td>public void flush() throws Exception</td><td>普通</td><td>刷新缓冲区</td></tr><tr><td>3</td><td>public void write(byte[] b) throws Exception</td><td>普通</td><td>将一个byte数组写入数据流</td></tr><tr><td>4</td><td>public void write(byte[] b, int off, int len) throws Exception</td><td>普通</td><td>将一个指定范围的byte[]数组写入数据流</td></tr><tr><td>5</td><td>public abstract void write(int b) throws Exception</td><td>普通</td><td>将一个字节数据写入数据流</td></tr></tbody></table><h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h5><h6 id="向文件中写入数据"><a href="#向文件中写入数据" class="headerlink" title="向文件中写入数据"></a>向文件中写入数据</h6><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;public class main {    public static void main(String[] args) throws Exception{        //第一步：使用File找到一个文件        File file = new File(&quot;/Users/syz/Documents&quot; + File.separator + &quot;test.txt&quot;);        //第二步：通过FileOutputScream子类实例化父类对象        OutputStream out = new FileOutputStream(file);        //第三步：进行写操作        String str  = &quot;nihao!!!&quot;;        byte[] b = str.getBytes();        out.write(b);//        //通过write(int b)输出//        for (int i = 0; i&lt;b.length; i++) {//            out.write(b[i]);//        }        //第四步：关闭输出流        out.close();    }}</code></pre><h6 id="追加新内容"><a href="#追加新内容" class="headerlink" title="追加新内容"></a>追加新内容</h6><p>之前我们已经在指定的路径中创建文件，并写入了数据，如果我们在执行上述程序，那么新的文件就会覆盖掉旧的文件。为了解决这个问题，FileOutputScream类还有另外一个构造方法：<br><code>public FileOutputScream(File file, boolean append) throws FileNotFoundException</code><br>对于append我们会比较输入，它的翻译为“追加”，这里将boolean类型的append变量赋值为true，就表示可以在文件的末尾追加新的内容。</p><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;public class main {    public static void main(String[] args) throws Exception{        //第一步：使用File找到一个文件        File file = new File(&quot;/Users/syz/Documents&quot; + File.separator + &quot;test.txt&quot;);        //第二步：通过FileOutputScream子类实例化父类对象        OutputStream out = new FileOutputStream(file, true);  //使用FileOutputStream(File file, append true)构造方法        //第三步：进行写操作        String str  = &quot;\r\nnihao!!!&quot;;  //“\r\n”表示换行         byte[] b = str.getBytes();        out.write(b);//        //通过write(int b)输出//        for (int i = 0; i&lt;b.length; i++) {//            out.write(b[i]);//        }        //第四步：关闭输出流        out.close();    }}</code></pre><h4 id="字节输入流-InputScream"><a href="#字节输入流-InputScream" class="headerlink" title="字节输入流  InputScream"></a>字节输入流  InputScream</h4><p>程序可以向文件中写入内容，我们就可以使用InputScream从文件中把数据读取出来。InputScream类的定义：<br><code>public abstract class InputScream extends Object implements Closeable</code><br>与OutputScream一样，InputScream也是一个抽象类，必须依靠子类FileInputScream类通过向上转型实例InputScream类。FileInputScream类的构造方法：<br><code>publci FileInputScream(File file) throws FileNotFoundException</code></p><p>InputScream类的常用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public int available() throws Exception</td><td>普通</td><td>可以去的输入文件的大小</td></tr><tr><td>2</td><td>public void close() throws Exception</td><td>普通</td><td>关闭输入流</td></tr><tr><td>3</td><td>public abstract int read() throws Exception</td><td>普通</td><td>读取内容，以数字的方式读取</td></tr><tr><td>4</td><td>public int read(byte[] b) throws Exception</td><td>普通</td><td>将内容读到byte数组中，同时返回读入的个数</td></tr></tbody></table><h5 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h5><pre><code>import java.io.*;public class main {    public static void main(String[] args) throws Exception{        //第一步：使用File找到一个文件        File file = new File(&quot;/Users/syz/Documents&quot; + File.separator + &quot;test.txt&quot;);        //第二步：通过FileOutputScream子类实例化父类对象        InputStream input = new FileInputStream(file);        //第三步：进行写操作        byte[] b = new byte[1024];        int len = input.read(b);//        //通过read(int b)输出//        int len = 0;//        int temp = 0;//        while((temp = input.read()) != -1) {//            b[len] = (byte)temp;//            len++;//        }        //第四步：关闭输出流        input.close();        System.out.println(&quot;内容为：&quot;+ new String(b, 0, len));    }}</code></pre><p>因为开辟的byte数组的空间为1024，我们的字符串的空间只有十几个字节，所有读取出来的字符串后面会有很多空格，当我们将byte数组转换成字符串时，也将这些空格转换成了字符串。read(byte[] b）方法在读取内容的同时也会返回读入的个数,我们可以利用返回的个数，将byte数组指定范围的内容变成字符串输出。<br>在输入流读取的时候，正常情况下是不会返回数字的，只有当输入流的内容到了文件末，才会返回数字-1，我们可以通过这个数字判断输入流是否还有其他内容。</p><h3 id="2-字符流"><a href="#2-字符流" class="headerlink" title="2. 字符流"></a>2. 字符流</h3><p>字符流是针对字符数据的特点进行优化的，一个字符等于两个字节。字符流的源或目标通常是文本文件。java.io包提供了Reader和Writer两个字符流的类。由于它们都是抽象类，所以应使用它们的子类来创建实体对象，利用对象来处理相关的读写操作。<br><img src="media/15518464643263/15518519989564.jpg" alt></p><h4 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h4><p>Writer类的定义为：<br><code>public abstract class Writer extends Object implements Appendable, Closeable, Flushable</code><br>向文件写入内容时需要使用子类FileWriter的子类，FileWriter类的定义：<br><code>public FileWriter(File file) throws IOPException</code><br>和字节输出流一样，FileWriter也有另外一个构造方法用于在文件末追加内容<br><code>public FileWriter(File file, boolean append) throws IOPException</code></p><p>Wrier类的常用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public abstract void close() throws IOException</td><td>普通</td><td>关闭输出流</td></tr><tr><td>2</td><td>public void write(String str) throws IOException</td><td>普通</td><td>将字符串输出</td></tr><tr><td>3</td><td>public void writer(char[] ch) throws IOException</td><td>普通</td><td>将字符数组输出</td></tr><tr><td>4</td><td>public abstract void flush() throws IOException</td><td>普通</td><td>强制性清空缓存</td></tr></tbody></table><h5 id="Demo-3"><a href="#Demo-3" class="headerlink" title="Demo"></a>Demo</h5><pre><code>import java.io.*;public class main {    public static void main(String[] args) throws Exception{        //第一步：使用File找到一个文件        File file = new File(&quot;/Users/syz/Documents&quot; + File.separator + &quot;test.txt&quot;);        //第二步：通过FileOutputScream子类实例化父类对象        Writer out = new FileWriter(file, true);        //第三步：进行写操作        String str = &quot;nihao!!!&quot;;        out.write(str);//        //通过read(int b)输出//        int len = 0;//        int temp = 0;//        while((temp = input.read()) != -1) {//            b[len] = (byte)temp;//            len++;//        }        //第四步：关闭输出流        out.close();    }}</code></pre><h4 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h4><p>Reader是使用字符的方式从文件中读取数据的，Reader类的定义：<br><code>public abstract class Reader extends Object implements Readable, Closeable</code><br>Reader本身同样也是抽象类，同样需要子类FileReader的子类通过向上转型实例化Reader类。<br><code>public FileReader(File file) throws FileNotFoundException</code></p><p>Reader类的常用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public abstract void close() throws IOException</td><td>普通</td><td>关闭输入流</td></tr><tr><td>2</td><td>public int read() throws IOException</td><td>普通</td><td>读取单个字符</td></tr><tr><td>3</td><td>public int read(char[] ch) throws IOException</td><td>普通</td><td>将内容读取到数组中，返回读入的长度</td></tr></tbody></table><h5 id="Demo-4"><a href="#Demo-4" class="headerlink" title="Demo"></a>Demo</h5><pre><code>import java.io.*;public class main {    public static void main(String[] args) throws Exception{        //第一步：使用File找到一个文件        File file = new File(&quot;/Users/syz/Documents&quot; + File.separator + &quot;test.txt&quot;);        //第二步：通过FileOutputScream子类实例化父类对象        Reader input= new FileReader(file);        //第三步：进行写操作       char[] c = new char[1024];       int len = input.read(c);//        //通过read(int b)输出//        int len = 0;//        int temp = 0;//        while((temp = input.read()) != -1) {//            b[len] = (char)temp;//            len++;//        }        //第四步：关闭输出流        input.close();        System.out.println(&quot;内容为：&quot;+ new String(c, 0, len));    }}</code></pre><h4 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h4><p>字节流和字符流的使用方法大致是相同的，他们之间的区别主要有三点：</p><ol><li>读写单位不同：字节流以byte（8bit）为单位，字符流以字符(2byte)为单位。</li><li>处理对象不同：字节流可能处理所有的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li><li>是否使用缓冲区：字节流没有，字符流使用了缓冲区（buffer）。</li></ol><h4 id="文本复制"><a href="#文本复制" class="headerlink" title="文本复制"></a>文本复制</h4><p>文本复制就是将一个文件的内容写到另一个文件中。文件复制有两种方法：</p><ul><li>先把全部内容读出来存到内存中，再存到目标文件中</li><li>采取边读边写的方式</li></ul><p>一般都是选用第二种方式，因为如果将源文件全部读出来的话，如果文件内容过多，则整个内存无法装下。</p><pre><code>import java.io.*;import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        String path1 = scanner.next();        String path2 = scanner.next();        File f1 = new File(path1);        File f2 = new File(path2);        if (!f1.exists()) {            System.out.println(&quot;源文件不存在&quot;);            System.exit(1);        }        InputStream input = null;        OutputStream output = null;        try {            input = new FileInputStream(f1);            output = new FileOutputStream(f2);        } catch (FileNotFoundException e) {            e.printStackTrace();        }        if (input != null &amp;&amp; output != null) {            int temp = 0;            try {                while ((temp = input.read()) != -1) {                    output.write(temp);                }                System.out.println(&quot;复制完成&quot;);            } catch (IOException e) {                e.printStackTrace();                System.out.println(&quot;复制失败了&quot;);            }            try {                input.close();                output.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><h2 id="四-转换流——OutputStreamWriter与InputStreamReader"><a href="#四-转换流——OutputStreamWriter与InputStreamReader" class="headerlink" title="四. 转换流——OutputStreamWriter与InputStreamReader"></a>四. 转换流——OutputStreamWriter与InputStreamReader</h2><ul><li>OutputStreamWriter：是Writer的子类，将输出的字符流变为字节流，即将一个字符流的输出对象转换成一个字节流的输出对象。</li><li>InputStreamReader：是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输入对象转换成一个字符流的输入对象。</li></ul><p><img src="https://ws1.sinaimg.cn/large/0077HGE3ly1g24lmwhx3qj32eu0r4x6q.jpg" alt><br>从图中可以发现不过如何操作，最终都会以字节的形式保存在文件中。</p><h4 id="将字节输出流转换成字符输出流"><a href="#将字节输出流转换成字符输出流" class="headerlink" title="将字节输出流转换成字符输出流"></a>将字节输出流转换成字符输出流</h4><pre><code>import java.io.*;public class Main {    public static void main(String[] args) {        File file = new File(&quot;/Users/syz/text.txt&quot;);        Writer out = null;        try {            out = new OutputStreamWriter(new FileOutputStream(file));//字节流转换成字符流            out.write(&quot;hello world&quot;); //使用字符流输出            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h4 id="将字符输入流转换成字节输出流"><a href="#将字符输入流转换成字节输出流" class="headerlink" title="将字符输入流转换成字节输出流"></a>将字符输入流转换成字节输出流</h4><pre><code>import java.io.*;public class Main {    public static void main(String[] args) {        File file = new File(&quot;/Users/syz/text.txt&quot;);        Reader reader = null;        try {           reader = new InputStreamReader(new FileInputStream(file));//字节流转换成字符流           char[] c = new char[1024];           int len = reader.read(c);           reader.close();            System.out.println(new String(c, 0, len));        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>以上两种方式都是以字符流的形式将字节流进行输入输出。</p><h2 id="五-内存操作流"><a href="#五-内存操作流" class="headerlink" title="五. 内存操作流"></a>五. 内存操作流</h2><p>Java不只是可以将数据输入输出到文件中，也可以将数据输入输出到内存中。此时主要使用ByteArrayInputStream和ByteArrayOutputStream来完成内存的输入和输出功能。</p><blockquote><p>使用场景：内存操作流一般在生成一些信息时才会使用，如果将这些临时信息保存在文件中，则代码执行完后肯定还要删除这个临时文件会比较麻烦，这是使用内存操作流是最合适的。</p></blockquote><p>ByteArrayInputStream类的主要方法:</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public ByteArrayInputStream(byte[] bud)</td><td>构造</td><td>将全部的内容写入内存中</td></tr><tr><td>2</td><td>Public ByteArrayOutputStream(byte[] bud, int offset, int length)</td><td>构造</td><td>将指定范围的内容写入到内存中</td></tr></tbody></table><p>ByteArrayOutputStream类的主要方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Public ByteArrayOutputStream()</td><td>构造</td><td>创建对象</td></tr><tr><td>2</td><td>Public void write(int b)</td><td>普通</td><td>将内容从内存中输出</td></tr></tbody></table><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {        String str = &quot;HELLO WORLD&quot;;        ByteArrayInputStream bis = null; //声明内存输入流        ByteArrayOutputStream bos = null; //声明内存输出流        bis = new ByteArrayInputStream(str.getBytes()); //向内存中输出内容        bos = new ByteArrayOutputStream(); //准备从ByteArrayOutputStream中读取数据        int temp = 0;        while ((temp = bis.read()) != -1) {            char c = (char) temp;            bos.write(Character.toLowerCase(c));        }        String newStr = bos.toString();        try {            bis.close();            bos.close();        } catch (IOException e) {            e.printStackTrace();        }        System.out.println(newStr);    }}</code></pre><h2 id="六-管道流"><a href="#六-管道流" class="headerlink" title="六. 管道流"></a>六. 管道流</h2><p>管道流主要是在两个线程之间进行通信，分为：管道输出流(PipedOutputStream)和管道输入流(PipedInputStream)。 如果要进行管道输出，则必须把输出流链接在输入流上，在PipedOutputStream类上有如下方法用于连接管道：<br><code>public void connect(PipedInputStream snk) throws IOException</code><br><img src="https://ws1.sinaimg.cn/large/0077HGE3ly1g24nbrm47ej32zi0x44mg.jpg" alt></p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {       Send s = new Send();       Rexeive r = new Rexeive();       try {           s.getPos().connect(r.getPis());       } catch (IOException e) {           e.printStackTrace();       }       new Thread(s).start();       new Thread(r).start();    }}class Send implements Runnable{    private PipedOutputStream pos = null;    public Send() {        this.pos = new PipedOutputStream();  //实例化输出流    }    @Override    public void run() {        String str = &quot;Hello World!!!&quot;;        try {            this.pos.write(str.getBytes());        } catch (IOException e) {            e.printStackTrace();        }        try {            this.pos.close();        } catch (IOException e) {            e.printStackTrace();        }    }    public PipedOutputStream getPos() {        return pos;    }}class Rexeive implements Runnable{    private PipedInputStream pis = null;    public Rexeive() {        this.pis = new PipedInputStream(); //实例化输入流    }    @Override    public void run() {        byte[] b = new byte[1024];        int len = 0;        try {            len = this.pis.read(b);        }catch (IOException e) {            e.printStackTrace();        }        try {            this.pis.close();        } catch (IOException e) {            e.printStackTrace();        }        System.out.println(&quot;接收的内容为：&quot;+new String(b, 0, len));    }    public PipedInputStream getPis() {        return pis;    }}</code></pre><h2 id="七-打印流"><a href="#七-打印流" class="headerlink" title="七. 打印流"></a>七. 打印流</h2><p>在整个I/O包中，打印流式输出最方便的类了，主要包含字节打印流(PrintStream)和字符打印流(PrintWriter)。打印流可以打印任何数据类型，如小数、整数、字符串等。今天主要讲解PrintStream类，PrintWriter类用法与其类似。<br>PrintStream时OutputStream的子类，PrintStream类的常用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Public PrintStream(File file) throws FileNotFoundException</td><td>构造</td><td>通过一个File对象实例化PrintStream类</td></tr><tr><td>2</td><td>public PrintStream(OutputStream out)</td><td>构造</td><td>接收OutputStream对象，实例化printStream类</td></tr><tr><td>3</td><td>public PrintStream printf(Local l, String format, Object…args)</td><td>普通</td><td>根据指定的Locale进行格式化输出</td></tr><tr><td>4</td><td>public PringStream printf(String format, Object…args)</td><td>普通</td><td>根据本地环境格式化输出</td></tr><tr><td>5</td><td>public void print(boolean b)</td><td>普通</td><td>此方法被重载很多次，输出任意数据</td></tr><tr><td>6</td><td>public void println(boolean b)</td><td>普通</td><td>此方法被重载很多次，输出任意数据后换行</td></tr></tbody></table><p>JDK1.5之后，Java又对PrintStream类进行了扩充，增加了格式化输出方式：</p><table><thead><tr><th>序号</th><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>%s</td><td>表示内容为字符串</td></tr><tr><td>2</td><td>%d</td><td>表示内容为整数</td></tr><tr><td>3</td><td>%f</td><td>表示内容为小数</td></tr><tr><td>4</td><td>%c</td><td>表示内容为字符</td></tr></tbody></table><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {       PrintStream ps = null;       //通过FileOutputStream实例化，表明所有的输出是向文件中打印       ps = new PrintStream(new FileOutputStream(new File(&quot;/Users/syz/text.txt&quot; +               &quot;&quot;)));       ps.print(&quot;Hello&quot;);       ps.println(&quot;world&quot;);       ps.println(&quot;1+1=2&quot;);       //格式化输出       String name = &quot;张三&quot;;       int age = 30;       float score = 990.3f;       char sex = &#39;M&#39;;       ps.printf(&quot;姓名：%s；年龄：%d； 成绩：%f；性别：%c&quot;, name, age, score, sex);       ps.close();    }}</code></pre><h2 id="八-System类对IO的支持"><a href="#八-System类对IO的支持" class="headerlink" title="八. System类对IO的支持"></a>八. System类对IO的支持</h2><p>System表示系统类，Java中System对IO给予了一定的支持，在System中定义了3个常量：</p><table><thead><tr><th>序号</th><th>System类的常量</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public static final PrintStream out</td><td>对应系统标准输出，一般是显示器</td></tr><tr><td>2</td><td>public static final PrintStream err</td><td>错误信息输出</td></tr><tr><td>3</td><td>public static final PrintStream in</td><td>对应着标准输入，一般是键盘</td></tr></tbody></table><h4 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h4><p>System.out是PrintStream的对象，在PrintStream中定义了一系列的print()和println()方法，所以前面使用的System.out.print()和System.out.println()语句调用的就是PrintStream类的方法。<br>System.out表示的是向显示器输出，而PrintStream有事OutputStream的子类，所以可以使用此对象直接实例化OutputStream对象，使OutputStream对象可以直接向显示器输出。</p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) {        OutputStream out = System.out;        try {            out.write(&quot;hello world&quot;.getBytes());        }catch (IOException e ) {            e.printStackTrace();        }        try {            out.close();        }catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>以上信息是直接使用OutputStream向屏幕输出，也就是说，OutputStream被那个子类实例化，就具备了向哪里输出的功能，比如使用FileOutputStrean实例化就可以向文件输出，使用了System.out实例化就可以向显示器输出。这里完全显示了Java的多态性</strong></p><h4 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h4><p>System.err表示的是错误信息的输出，但是对于异常的输出结果，他和System.out的功能是一样的，我们只能通过他的概念来区别他俩。System.out输出正常内容，System.err输出错误信息，并且System.err输出的错误信息爆红。以后抛出异常时，就可以使用System.err打印异常。</p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) {       String str = &quot;hello&quot;;       try {           System.out.print(Integer.parseInt(str));       } catch (Exception e){           System.err.print(e);       }    }}</code></pre><h4 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h4><p>System.in实际上是一个键盘的输入流，其本身是inputStream类型的对象。我们可以通过System.in完成从键盘读取数据的功能。<br>这里建议不直接使用System.in直接读取键盘数据，因为但我们把键盘的数据度读入一个数组的时候，数组会有空间限制，如果不指定数组的大小则输入中文的时候又会出现乱码。<br>最好的输入方式就是将数据全部输入到一块内存中，然后一次性从内存中读取出全部数据。我们建议System.in和BufferedReader类一起使用。</p><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><p>Java可以通过System类改变System.in的输入来源以及System.out和System.err的输出位置：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Public static void setOut(PringStream out)</td><td>普通</td><td>重定向“标准”输出流</td></tr><tr><td>2</td><td>public statif void setErr(PrintStream err)</td><td>普通</td><td>重定向“标准”错误输出流</td></tr><tr><td>3</td><td>public static void setin(InputStream in)</td><td>普通</td><td>重定向“标准”输入流</td></tr></tbody></table><h5 id="System-out的重定向"><a href="#System-out的重定向" class="headerlink" title="System.out的重定向"></a>System.out的重定向</h5><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception{        System.setOut(new PrintStream(new FileOutputStream(&quot;/Users/syz/text.txt&quot;))); //输出重定向        System.out.print(&quot;www.conceal.github.io&quot;);    }}</code></pre><h5 id="System-err重定向"><a href="#System-err重定向" class="headerlink" title="System.err重定向"></a>System.err重定向</h5><p>我们不建议System.err重定向，以内err报错信息本来就是不想让人看见的。</p><h5 id="System-in重定向"><a href="#System-in重定向" class="headerlink" title="System.in重定向"></a>System.in重定向</h5><p>System.in的重定向是重定向System.in的数据来源。下面的例子是修改了System.in的输入位置，而将其输入重定向到文件读取，所以读取时会讲文件中的内容读取出来。</p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception{        System.setIn(new FileInputStream(&quot;/Users/syz/text.txt&quot;));        InputStream input = System.in;        byte[] b= new byte[1024];        int len = input.read(b);        System.out.println(&quot;输出内容为：&quot;+ new String(b, 0, len));        input.close();    }}</code></pre><h2 id="九-BufferedReader类"><a href="#九-BufferedReader类" class="headerlink" title="九. BufferedReader类"></a>九. BufferedReader类</h2><p>BufferedReader类用于从缓冲区中读取内容，所有的输入字节数据都将放在缓冲区中。：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Public BufferedReader(Reader in)</td><td>构造</td><td>接收一个Reader类型的实例</td></tr><tr><td>2</td><td>public String readLine() throws IOException</td><td>普通</td><td>一次性从缓冲区中将内容全部读取出来</td></tr></tbody></table><p>BufferedReader中定义的构造方法只能接收字符输入流，所以必须使用字符输入流和字节输入流的转换流InputStreamReader将字节输入流System.in变为字符流。这也是上面讲的为什么不建议单独使用System.in</p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception{        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));        String str = null;        System.out.print(&quot;请输入内容：&quot;);        try {            str = buf.readLine();        } catch (IOException e) {            System.err.print(e);        }        System.out.print(&quot;输入的内容为：&quot; + str);    }}</code></pre><h2 id="十-Scanner类"><a href="#十-Scanner类" class="headerlink" title="十. Scanner类"></a>十. Scanner类</h2><p>在JDK1.5之后提供了专门的输入数据类Scanner类。</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public Scanner(File source) throws FileNotFoundException</td><td>构造</td><td>从文件中读取内容</td></tr><tr><td>2</td><td>public Scanner(InputStream source)</td><td>构造</td><td>从指定的字节输入流中接收内容</td></tr><tr><td>3</td><td>public boolean hasNext(Patten patten)</td><td>普通</td><td>判断输入的数据是否符合指定的正则标准</td></tr><tr><td>4</td><td>public boolean hasNextInt()</td><td>普通</td><td>判断输入的是否是整数</td></tr><tr><td>5</td><td>public boolean hasNextFloat()</td><td>普通</td><td>判断输入的是否是小数</td></tr><tr><td>6</td><td>public String Next()</td><td>普通</td><td>接收内容</td></tr><tr><td>7</td><td>public String Next(Pattern pattern)</td><td>普通</td><td>接收内容，进行正则验证</td></tr><tr><td>8</td><td>public int NextInt()</td><td>普通</td><td>接收数字</td></tr><tr><td>9</td><td>public float nextFloat()</td><td>普通</td><td>接收小数</td></tr><tr><td>10</td><td>public Scanner useDelimiter(String pattern)</td><td>普通</td><td>设置读取的分隔符</td></tr></tbody></table><pre><code>import java.io.*;import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner scan = new Scanner(System.in);        //输入数据        System.out.print(&quot;请输入数据：&quot;);        String str = scan.next();        System.out.println(&quot;输入的数据为：&quot;+str);        //修改输入数据的分隔符        System.out.print(&quot;请输入数据：&quot;);        scan.useDelimiter(&quot;\n&quot;);        String str1 = scan.next();        System.out.println(&quot;输入的数据为：&quot;+str1);    }}</code></pre><h2 id="十一-数据操作流"><a href="#十一-数据操作流" class="headerlink" title="十一. 数据操作流"></a>十一. 数据操作流</h2><p>在IO包中，提供了两个和平台无关的数据操作流，分别为数据输出流(DataOutputStream)和数据输入流(DataInputStream),通常数据输出流会按照一定的格式将数据输出，再通过数据输入流按照一定的格式将数据读入。</p><h4 id="DataOutputStream类"><a href="#DataOutputStream类" class="headerlink" title="DataOutputStream类"></a>DataOutputStream类</h4><p>DataOutputStream时OutputStream的子类：<br><code>public class DataOutputStream extends FilterOutputStream implements DataInput</code><br>此类继承自FilterOutputStream(FilterOutputStream是OutputStream的子类),同时实现了DataOutput接口，在DataOutput接口定义了一系列的写入各种数据的方法。<br>DataOutputStream类的常用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public DataOutputStream(OutputStream out)</td><td>构造</td><td>实例化对象</td></tr><tr><td>2</td><td>public final void writeInt(int v) throws IOException</td><td>普通</td><td>将一个int值以4-byte值形式写入基础输出流中</td></tr><tr><td>3</td><td>public final void writeDouble(double v) throws IOException</td><td>普通</td><td>写入一个double类型的数据，该值以8-byte值形式写入到基础输出流中</td></tr><tr><td>4</td><td>public final void writeChars(String s) throws IOException</td><td>普通</td><td>将一个字符串写入到输出流中</td></tr><tr><td>5</td><td>public final void writeChar(int v) throws IOException</td><td>普通</td><td>将一个字符写入到输出流中</td></tr></tbody></table><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {        DataOutputStream dos = null;        File f = new File(&quot;/Users/syz/text.txt&quot;);        dos = new DataOutputStream(new FileOutputStream(f));        String[] name = {&quot;衬衣&quot;, &quot;手套&quot;, &quot;围巾&quot;};        float[] prices = {98.3f, 30.3f, 50.5f};        int[] nums = {3, 2, 1};        for (int i = 0; i &lt; name.length; i++) {            dos.writeChars(name[i]);            dos.writeChar(&#39;\t&#39;);            dos.writeFloat(prices[i]);            dos.writeChar(&#39;\t&#39;);            dos.writeInt(nums[i]);            dos.writeChar(&#39;\n&#39;);        }        dos.close();    }}</code></pre><h4 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h4><p>DataInputStream类是inputStream的子类，专门负责读取用DataOutputStream输出的数据：<br><code>public class DataInputStream extends FilterInputStream implements</code><br>此类继承自FilterInputStream类(FilterInputStream是InputStream的子类），同时实现DataInput接口，在DataInput接口中定义了一系列读入各种数据的方法。<br>DataInputStream类常用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public DataInputStream(InputStream in)</td><td>构造</td><td>实例化对象</td></tr><tr><td>2</td><td>public final int readInt() throws IOException</td><td>普通</td><td>从输入流中读取整数</td></tr><tr><td>3</td><td>public final float readFloat() throws IOException</td><td>普通</td><td>从输入流中读取小数</td></tr><tr><td>4</td><td>public final char readChar() throws IOException</td><td>普通</td><td>从输入流中读取一个字符</td></tr></tbody></table><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {        DataInputStream dis = null;        File f = new File(&quot;/Users/syz/text.txt&quot;);        dis = new DataInputStream(new FileInputStream(f));        String name = null;        float price = 0.0f;        int num = 0;        char[] temp = null;        char c = 0;        int len = 0;        try {            while (true) {                temp = new char[200];                len = 0;                while ((c = dis.readChar()) != &#39;\t&#39;) {                    temp[len] = c;                    len++;                }                name = new String(temp, 0, len);                price = dis.readFloat();                dis.readChar();                num = dis.readInt();                dis.readChar();                System.out.printf(&quot;名称：%s; 价格：%5.2f; 数量：%d\n&quot;, name, price, num);            }        } catch (Exception e) {            System.err.print(e);        }        dis.close();    }}</code></pre><h2 id="十一-文件合并流"><a href="#十一-文件合并流" class="headerlink" title="十一.  文件合并流"></a>十一.  文件合并流</h2><p>文件合并流。顾名思义就是将两个文件合并成一个文件。如果要实现合并流，则必须使用SequenceinputStream类：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public SequenceInputStream(InputStream input1, InputStream input2)</td><td>构造</td><td>使用两个输入流对象实例化本类对象</td></tr><tr><td>2</td><td>public int available() throws IOException</td><td>普通</td><td>返回文件大小</td></tr></tbody></table><pre><code>import jdk.internal.util.xml.impl.Input;import java.io.*;public class Main {    public static void main(String[] args) throws Exception {        OutputStream out1 = new FileOutputStream(new File(&quot;/Users/syz/a.txt&quot;)); //创建a.txt文件,内容自己写入吧        OutputStream out2 = new FileOutputStream(new File(&quot;/Users/syz/b.txt&quot;)); //创建b.txt文件，内容自己写入吧        InputStream input1 = new FileInputStream(new File(&quot;/Users/syz/a.txt&quot;));        InputStream input2 = new FileInputStream(new File(&quot;/Users/syz/b.txt&quot;));        OutputStream out = new FileOutputStream(new File(&quot;/Users/syz/ab.txt&quot;));        SequenceInputStream sis = new SequenceInputStream(input1, input2);        int temp = 0;        while ((temp = sis.read()) != -1) {            out.write(temp);        }        input1.close();        input2.close();        out.close();        out1.close();        out2.close();        sis.close();    }}</code></pre><p>以上的程序在实例化SequenceStream类时指定了连个输入流，所以SquenceStream类在进行读取时实际上是从两个输入流中一起读取内容。</p><h2 id="十二-文件压缩流"><a href="#十二-文件压缩流" class="headerlink" title="十二.  文件压缩流"></a>十二.  文件压缩流</h2><blockquote><p>在Java中为了减少数据的传输量专门提供了压缩流，可以将文件压缩成ZIP、JAR、GZIP等文件形式。</p></blockquote><p>ZIP是一种较为常见的压缩形式，在Java中要实现ZIP的压缩需要导入java.util.zip包，可以使用此包中的ZipFlie、ZipOutputStream、ZipinputStream和ZipEntry等几个类完成操作。<br>在每一个压缩文件中都会存在多个子文件，那么每一个压缩文件在Java中就可以使用ZipEntry表示。ZipEntry类的常用方法：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public ZipEntry(String name)</td><td>构造</td><td>创建对象并指定要创建的ZipEntry名称</td></tr><tr><td>2</td><td>public boolean isDirectory()</td><td>普通</td><td>判断此ZipEntry是否是目录</td></tr></tbody></table><blockquote><p>压缩的输入/输出类定义在java.util.zip包中，但是压缩的输入/输出流也属于InputStream/OutputStream的子类，当时却没有定义在java.io包中，而是以一种工具类的形式提供的，在操作时还需要使用java.io包的支持。</p></blockquote><h3 id="1-ZipOutputStream类"><a href="#1-ZipOutputStream类" class="headerlink" title="1. ZipOutputStream类"></a>1. ZipOutputStream类</h3><p>如果要完成一个文件或文件夹的压缩，就要使用ZipOutputStream类。ZipOutputStream是OutputStream的子类，常用操作方法如下：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public ZipOutputStream(OutputStream out)</td><td>构造</td><td>创建一个zip输出流</td></tr><tr><td>2</td><td>public void putNextEntry(ZipEntry) throws IOException</td><td>普通</td><td>设置一个ZipEntry对象</td></tr><tr><td>3</td><td>public void setComment(String comment)</td><td>普通</td><td>设置ZIP文件的注释</td></tr></tbody></table><h4 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h4><p><strong>压缩文件的步骤：</strong></p><ol><li>定义要压缩的文件</li><li>定义压缩文件的名称</li><li>实例化要压缩文件的输入流对象</li><li>实例化压缩输出流对象</li><li>设置ZipEntry和注释</li><li>使用输入流对象读取文件并使用压缩输出流将内容写入压缩文件</li></ol><pre><code>import jdk.internal.util.xml.impl.Input;import java.io.*;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class Main {    public static void main(String[] args) throws Exception {        File file = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + &quot;a.txt&quot;);  //定义要压缩的文件        File zipfile = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + &quot;a.zip&quot;); //定义压缩文件的名称        InputStream input = new FileInputStream(file);    //定义输入文件流        ZipOutputStream zipOut = zipOut = new ZipOutputStream(new FileOutputStream(zipfile));;  //实例化压缩输出流对象，并指定压缩文件的输出路径        zipOut.putNextEntry(new ZipEntry(file.getName()));  //创建ZipEntry        zipOut.setComment(&quot;www.conceal.github.io&quot;);        //设置注释        int temp = 0;        while ((temp = input.read()) != -1) {            zipOut.write(temp);        }        input.close();        zipOut.close();    }}</code></pre><h4 id="压缩文件夹"><a href="#压缩文件夹" class="headerlink" title="压缩文件夹"></a>压缩文件夹</h4><p>一个文件夹中含有多个文件，如果要压缩一个文件夹,则必须将文件夹中的每一个文件列出然后在逐个压缩。<br><img src="https://ws1.sinaimg.cn/large/0077HGE3ly1g272p4whsej30a90g03yv.jpg" alt></p><pre><code>import jdk.internal.util.xml.impl.Input;import java.io.*;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class Main {    public static void main(String[] args) throws Exception {        File file = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + &quot;conceal&quot;);  //定义要压缩的文件夹        File zipFile = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + &quot;conceal.zip&quot;);  //定义压缩文件夹名称        InputStream input = null;         //定义输入流        ZipOutputStream zipOut = null;    //定义压缩输出流        zipOut = new ZipOutputStream(new FileOutputStream(zipFile));   //实例化压缩输出流对象        zipOut.setComment(&quot;www.conceal.github.io&quot;);   //设置注释        if (file.isDirectory()) {       //判断file是否是一个文件夹            File[] list = file.listFiles();            for (int i = 0; i &lt; list.length; i++) {                input = new FileInputStream(list[i]);                //每一个被压缩的文件都用zipEntry表示,需要为每一个压缩文件设置名称                zipOut.putNextEntry(new ZipEntry(file.getName() + File.separator + list[i].getName()));                int temp = 0;                while ((temp = input.read()) != -1) {                    zipOut.write(temp);                }                input.close();            }            zipOut.close();        }    }}</code></pre><h3 id="2-ZipFile类"><a href="#2-ZipFile类" class="headerlink" title="2. ZipFile类"></a>2. ZipFile类</h3><p>在Java中，每一个压缩文件可以使用ZipFile表示，还可以使用ZipFile根据压缩后的文件名称找到每一个压缩文件中的ZipEntry并将其解压。<strong>注意：ZipFile只适合于解压一个压缩文件或者只有一个文件的压缩文件夹。</strong></p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public ZipFile(File file) throws ZipException, IOException</td><td>构造</td><td>根据File类实例化ZipFile对象</td></tr><tr><td>2</td><td>public ZipEntry getEntry(String name)</td><td>普通</td><td>根据名称找到其对应的ZipEntry</td></tr><tr><td>3</td><td>public InputStream getInpustream(Zipentry entry) throws IOException</td><td>普通</td><td>根据ZipEntry取得InputStream实例</td></tr><tr><td>4</td><td>public String getName()</td><td>普通</td><td>得到压缩文件的路径名称</td></tr></tbody></table><p><strong>步骤：</strong></p><ol><li>找到压缩文件</li><li>定义解压文件的名称</li><li>实例化zipFile对象</li><li>利用zipFile对象根据根据压缩后的文件名称找到压缩文件的ZipEntry</li><li>获取压缩文件的输入流</li><li>获取解压文件的输出流</li><li>循环读取写入</li></ol><pre><code>import java.io.*;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;public class Main {    public static void main(String[] args) throws Exception {        File file = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + &quot;a.txt.zip&quot;); //找到压缩文件        File outputFile = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + &quot;a.txt&quot;);//定义解压缩的文件名称        ZipFile zipFile = new ZipFile(file);     //实例化zipFile对象        ZipEntry zipEntry = zipFile.getEntry(&quot;a.txt&quot;);        InputStream input = zipFile.getInputStream(zipEntry);        OutputStream out = new FileOutputStream(outputFile);        int temp = 0;        while ((temp = input.read()) != -1) {            out.write(temp);        }        input.close();        out.close();    }}</code></pre><h3 id="3-ZipInputStream类"><a href="#3-ZipInputStream类" class="headerlink" title="3. ZipInputStream类"></a>3. ZipInputStream类</h3><p>ZipInputStream是InputStream类的子类，通过此类可以方便的读取ZIP格式的压缩文件。</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public ZipInputStream(InputStream)</td><td>构造</td><td>实例化ZipInputStream兑现</td></tr><tr><td>2</td><td>public ZipEntry getNextEntry() throws IOException</td><td>普通</td><td>取得下一个ZipEntry，通过此方法可以一次取得每一个ZipEntry</td></tr></tbody></table><p>在压缩文件中本身是包含压缩的文件夹的，所以在进行解压缩之前，应该先根据ZIP文件中的文件夹的名称在硬盘上创建一个对应的文件夹，然后才能把文件解压缩进去，而且在操作时对于每一个解压缩的文件都必须先创建文件后再将内容输出。</p><pre><code>import java.io.*;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;import java.util.zip.ZipInputStream;public class Main {    public static void main(String[] args) throws Exception {        File file = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + &quot;conceal.zip&quot;); //找到压缩文件        File outFile = null; //定义输出的文件对象        ZipFile zipFile = new ZipFile(file);   //实例化ZipFile对象        ZipInputStream zinInput = new ZipInputStream(new FileInputStream(file));  //实例化ZIP输入流        ZipEntry entry = null;   //定义一个ZipEntry对象，用于接收压缩文件中的每一个实体        InputStream input = null;   //定义输入流，用于读取每一个ZipEntry        OutputStream out = null;     //定义输出流，用于输出每一个实体内容        while ((entry = zinInput.getNextEntry()) != null) {            System.out.println(&quot;解压缩&quot;+entry.getName()+&quot;文件&quot;);            outFile = new File(File.separator + &quot;Users&quot; + File.separator + &quot;syz&quot; + File.separator + entry.getName());            if (!outFile.getParentFile().exists()) {                outFile.getParentFile().mkdir();            }            if (!outFile.exists()) {                outFile.createNewFile();            }            input = zipFile.getInputStream(entry); //得到压缩实体的输入流            out = new FileOutputStream(outFile);            int temp = 0;            while ((temp = input.read()) != -1) {                out.write(temp);            }            input.close();            out.close();        }    }}</code></pre><p>以上程序首先通过ZipInputStream读取ZIP格式的压缩文件，然后通过getNextEntry方法依次读取出其中的每一个ZipEntry对象名称，并通过ZipFile类取得每一个ZipFile的输入流对象，在进行文件输出前，判断其输出文件夹及文件是否存在，如果不在则创建。</p><h2 id="十三-回退流"><a href="#十三-回退流" class="headerlink" title="十三.  回退流"></a>十三.  回退流</h2><p>在Java中，所有的内容都是采用顺序的读取方式的，即对于一个输入流来说，都是采用顺序的读取方式。但是，如果在一个流中，有些内容我们不需要该怎么办呢。这里Java推出了回退输入流（PushbackInputStream、PushbackReader），可以把读取进来的某些数据重新放回到输入流的缓冲区中，我们可以使用unread()方法将内容回退到输入流的缓冲区中。PushbackInputStream的方法如下：</p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public PushbackInputStream(InputStream input)</td><td>构造</td><td>将输入流放入回退流中</td></tr><tr><td>2</td><td>Public int read() throws IOException</td><td>普通</td><td>读取数据</td></tr><tr><td>3</td><td>public int read(byte[] b, int off, int len)</td><td>普通</td><td>读取指定范围的数据</td></tr><tr><td>4</td><td>pubic void unread() throws IOException</td><td>普通</td><td>回退一个数据到缓冲区前面</td></tr><tr><td>5</td><td>public void unread(byte[] b) throws IOException</td><td>普通</td><td>回退一组数据到缓冲区前面</td></tr><tr><td>6</td><td>Public void unread(byte[] b, int off, int len) throws IOException</td><td>普通</td><td>回退指定范围的一组数据到缓冲区前面</td></tr></tbody></table><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {        String str = &quot;www.conceal.github.io&quot;;        ByteArrayInputStream bai = new ByteArrayInputStream(str.getBytes()); //实例化内存输入流        PushbackInputStream push = new PushbackInputStream(bai);           //实例化回退流对象        System.out.print(&quot;读取之后的数据为：&quot;);        int temp = 0;        while ((temp = push.read()) != -1) {            if (temp == &#39;.&#39;) {                push.unread(temp);    //回退到缓冲区前面                temp = push.read();   //空出此数据，因为要读取下一个数据，所以要在缓冲区中读出在最前面的这个回退数据，一边继续读取后面的数据                System.out.print(&quot;(退回&quot;+(char)temp + &quot;)&quot;);            } else {                System.out.print((char)temp);            }        }    }}</code></pre><h2 id="十三-字符编码"><a href="#十三-字符编码" class="headerlink" title="十三.  字符编码"></a>十三.  字符编码</h2><p>计算机中常见的任何文字都是一指定的编码方式存在的，Java中的编码方式有ISO-1、GBK/GB2312、unicode、UTF编码。在程序中如果文本处理不好就会出现乱码。如果要避免出现乱码，则程序的编码方式要和本地的编码方式相同，可以通过System.getProperty()类获取本地编码方式。</p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {        final String PROPERTY = &quot;file.encoding&quot;;        System.out.println(&quot;系统默认的编码方式为：&quot;+ System.getProperty(PROPERTY));   //获取系统默认编码方式        File file = new File(&quot;/Users/syz/a.txt&quot;);        OutputStream out = new FileOutputStream(file);        byte[] a = &quot;中国&quot;.getBytes(&quot;ISO8859-1&quot;);  //指定ISO8859-1编码方式，和系统默认的编码方式不同，文件中会出现乱码        out.write(a);        out.close();    }}</code></pre><h2 id="十四-对象序列化"><a href="#十四-对象序列化" class="headerlink" title="十四.  对象序列化"></a>十四.  对象序列化</h2><blockquote><p>对象序列化就是把一个对象变为二进制的数据流的一种方法。通过对象的序列化可以方便对象的传输或存储，同时还可以提升传输效率。</p></blockquote><h3 id="1-Serializable接口"><a href="#1-Serializable接口" class="headerlink" title="1. Serializable接口"></a>1. Serializable接口</h3><p>如果一个类的对象想被序列化，则对象所在的类必须实现java.io.Serializable接口，此接口只是一个标识接口，表示一个类具备了被序列化的能力。。此接口定义：<br><code>public interface Serializable{}</code><br><strong>定义可被序列化的类：</strong></p><pre><code>import java.io.Serializable;public class Person implements Serializable {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String toString() {        return &quot;姓名：&quot;+ this.name + &quot;; 年龄：&quot; + this.age;    }}</code></pre><p>以上的Persion类已经实现了序列化接口，所以此类的对象是可以经过二进制数据流进行传输的。而如果要完成对象的输入输出，还必须依靠对象输出流(ObjectOutputStream)和对象输入流(ObjectInputStream)。<br>使用对象输出流输出序列化对象的步骤有时也被称为序列化，而使用对象输入流读入对象的过程也被称为反序列化。</p><h3 id="2-对象输出流ObjectOutputStream和对象输入流ObjectInputStream"><a href="#2-对象输出流ObjectOutputStream和对象输入流ObjectInputStream" class="headerlink" title="2. 对象输出流ObjectOutputStream和对象输入流ObjectInputStream"></a>2. 对象输出流ObjectOutputStream和对象输入流ObjectInputStream</h3><h4 id="对象输出流ObjectOutputStream"><a href="#对象输出流ObjectOutputStream" class="headerlink" title="对象输出流ObjectOutputStream"></a>对象输出流ObjectOutputStream</h4><p>ObjectOutputStream类属于OutputStream的子类，其定义和常见方法：<br><code>public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants</code></p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public ObjectOutputStream(OutputStream out) throws IOException</td><td>构造</td><td>传入输出流对象</td></tr><tr><td>2</td><td>public final void writeObject(Object obj) throws IOException</td><td>普通</td><td>输出对象</td></tr></tbody></table><p>此类的使用形式与PrintStream非常相似，在实例化时也需要传入一个OutputSrteam的子类对象，然后根据传入的OutputStream子类的对象的不同，输出的位置也不同。</p><h4 id="对象输入流ObjectInputStream"><a href="#对象输入流ObjectInputStream" class="headerlink" title="对象输入流ObjectInputStream"></a>对象输入流ObjectInputStream</h4><p>ObjectInputStream类属于InputStream的子类，其定义和常见的方法：<br><code>public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants</code></p><table><thead><tr><th>序号</th><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public ObjectInputStream(InputStream in) throws IOException</td><td>构造</td><td>构造输入对象</td></tr><tr><td>1</td><td>Public final Object readObject() throws IOException, ClassNotFoundException</td><td>普通</td><td>从指定位置读取对象</td></tr></tbody></table><p>此类的使用形式和ObjectOutputStream类一样，也是需要接收InputStream类的实例才可以实例化。</p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception {        ser();        dser();    }    public static void ser() throws Exception {        File file = new File(&quot;/Users/syz/text.txt&quot;);        file.createNewFile();        OutputStream out = new FileOutputStream(file);        ObjectOutputStream oos = new ObjectOutputStream(out);   //为对象输出流实例化        oos.writeObject(new Person(&quot;张三&quot;, 30));        oos.close();  //关闭输出    }    public static void dser() throws Exception {        File file = new File(&quot;/Users/syz/text.txt&quot;);        InputStream input = new FileInputStream(file);        ObjectInputStream ois = new ObjectInputStream(input);        Object obj = ois.readObject();        ois.close();        System.out.println(obj);    }}</code></pre><h3 id="3-Externalizable接口"><a href="#3-Externalizable接口" class="headerlink" title="3. Externalizable接口"></a>3. Externalizable接口</h3><p>被Serializable接口声明的类的对象的内容都将被序列化，如果现在用户想要自己指定序列化的内容，则可以让一个类实现Externalizable接口，此接口定义如下：</p><pre><code>public interface Externalizable extends Serializable {    public void writeExternal(ObjectOutput out) throws IOException;    public void readExternal(ObjectInput in) throws IOException;}</code></pre><p>Externalizable接口是Serilizable接口的字接口，在此接口中定义了两个方法，这两个方法的作用如下：</p><ul><li><strong>writerExternal(ObjectOutput out):</strong>在此方法中指定要保存的属性信息，对象序列化时调用。</li><li><strong>readExternal(ObjectInput in):</strong>在此方法中读取被保存的信息，对象反序列化时调用。<br>这两个方法的参数类型是ObjectOutput和ObjectInput，这两个接口的定义如下：<br><code>public interface ObjectOutput extends DataOutput</code><br><code>public interface ObjectInput extends DataInput</code><br>可以发现以上两个接口分别继承DataOutput和DataInput，这样在两个方法中就可以像DataOutputStream和DataInputStream那样直接输出和读取各种类型的数据。<br>如果一个类要使用Externalizable实现序列化时，在此类中必须存在一个无参构造方法。因为在反序列化时会默认调用无参构造实例化对象，如果没有此无参构造，则运行时会出现异常，这一点的实现机制与Serializable接口不同。</li></ul><h5 id="Persion类实现Externalizable"><a href="#Persion类实现Externalizable" class="headerlink" title="Persion类实现Externalizable"></a>Persion类实现Externalizable</h5><pre><code>import java.io.*;public class Person implements Externalizable {    private String name;    private int age;    public Person(){}    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String toString() {        return &quot;姓名：&quot;+ this.name + &quot;; 年龄：&quot; + this.age;    }    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {        this.name = (String) in.readObject();        this.age = in.readInt();    }    @Override    public void writeExternal(ObjectOutput out) throws IOException {        out.writeObject(this.name);        out.writeInt(this.age);    }}</code></pre><p>以上程序中的Persion类实现了Externalizable接口，这样用户就可以在类中有选择的保存需要的属性或者其他数据。</p><h3 id="4-transient关键字"><a href="#4-transient关键字" class="headerlink" title="4. transient关键字"></a>4. transient关键字</h3><p>Serilizable接口实现的操作实际上是一个对象中的全部属性进行实例化，当然也可以使用Externalizable接口实现部分属性的序列化，但是Externalizable比较麻烦。<br>当使用Serilizable接口实现序列化操作时，如果一个对像中的某个属性不希望被序列化，则可以使用transient关键字进行声明。</p><pre><code>import java.io.*;public class Person implements Serializable {   //此类的对象可以被序列化    private transient String name;              //此属性将不被序列化    private int age;                            //此属性可以被序列化    public Person(){}    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String toString() {        return &quot;姓名：&quot;+ this.name + &quot;; 年龄：&quot; + this.age;    }}</code></pre><h3 id="5-序列化一组对象"><a href="#5-序列化一组对象" class="headerlink" title="5. 序列化一组对象"></a>5. 序列化一组对象</h3><p>对象输出时只提供了一个对象的输出操作(writeObject(Object obj))，并没有提供多个对象的输出，所以如果现在要同时序列化多个对象，就可以使用对象数组进行操作，因为数组属于引用数据类型，所以可以直接使用Object类型进行接收。</p><pre><code>import java.io.*;public class Main {    public static void main(String[] args) throws Exception{        Person[] per = {new Person(&quot;张三&quot;, 30), new Person(&quot;李四&quot;, 31), new Person(&quot;王五&quot;, 32)};        ser(per);        Object[] o = dser();        for (int i = 0; i&lt;o.length; i++) {            Person p = (Person) o[i];            System.out.println(p);        }    }    public static void ser(Object[] obj) throws Exception {        File file = new File(&quot;/Users/syz/text.txt&quot;);        OutputStream out = new FileOutputStream(file);        ObjectOutputStream oos = new ObjectOutputStream(out);        oos.writeObject(obj);        oos.close();    }    public static Object[] dser() throws Exception {        File file = new File(&quot;/Users/syz/text.txt&quot;);        InputStream input = new FileInputStream(file);        ObjectInputStream ois = new ObjectInputStream(input);        Object[] obj = (Object[]) ois.readObject();        ois.close();        return obj;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼——继承与多态</title>
      <link href="/2019/04/09/yao-dian-ti-lian-ji-cheng-yu-duo-tai/"/>
      <url>/2019/04/09/yao-dian-ti-lian-ji-cheng-yu-duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类的继承"><a href="#一、类的继承" class="headerlink" title="一、类的继承"></a>一、类的继承</h2><p>在面向对象编程中，继承是一个缩短代码以及复用代码的良好的机制。一个继承了父类的子类，包含了父类所有的方法，也可以重载或添加新的内容。</p><h3 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h3><pre><code>[修饰符] class 子类名 extends 父类名 {    //子类体；}</code></pre><h3 id="2-子类对父类成员的可访问特性"><a href="#2-子类对父类成员的可访问特性" class="headerlink" title="2. 子类对父类成员的可访问特性"></a>2. 子类对父类成员的可访问特性</h3><p>子类是对父类的一种延伸，但是子类对父类成员变量的访问性确实由访问特性控制的。<br>如果父类和子类在同一个包中，那么子类可以访问父类的具有public、protected和默认访问特性的成员方法，对于private访问特性的成员方法，需要通过父类提供的操作接口实现。<br>如果父类和子类不再同一个包中，那么子类只能访问父类的具有public和protected访问特性的成员变量，对于默认访问特性以及private的访问特性的成员变量只能通过父类的操作接口实现。<br><img src="https://ws1.sinaimg.cn/large/0077HGE3ly1g1w3r905aqj33402bs4qq.jpg" alt></p><h3 id="3-子类构造方法的定义与执行"><a href="#3-子类构造方法的定义与执行" class="headerlink" title="3.子类构造方法的定义与执行"></a>3.子类构造方法的定义与执行</h3><p>在Java程序中，子类不负责调用父类的构造方法。在创建子类时需要在构造方法中利用super()调用父类的构造方法，注意这条语句要放在构造方法的第一行，如果子类没有调用父类的构造方法，子类会默认调用父类的无参构造方法。另外父类必须要构造无参构造方法，否则会出现编译错误。对于父类中的带参构造方法，子类不会默认调用，必须人工调用。</p><h2 id="二、类的成员方法的重载与覆盖"><a href="#二、类的成员方法的重载与覆盖" class="headerlink" title="二、类的成员方法的重载与覆盖"></a>二、类的成员方法的重载与覆盖</h2><h3 id="1-重载与覆盖"><a href="#1-重载与覆盖" class="headerlink" title="1. 重载与覆盖"></a>1. 重载与覆盖</h3><ol><li><p><strong>成员方法的重载</strong><br>所谓的重载是指在当一个类定义成员方法时，类定义一个与本类或父类的成员方法<strong>同名但参数列表不同</strong>的方法，在调用这个成员方法时，系统会根据参数列表匹配合适的成员方法。</p></li><li><p><strong>成员方法的覆盖</strong><br>在Java中，成员方法的名称和参数列表统称为签名。当子类的成员变量定义一个和父类的成员方法<strong>同名且参数列表也相同</strong>的成员方法时，这个成员方法就覆盖了父类或本类的成员方法了。当调用这个成员方法时，系统就会调用这个新的成员方法。</p></li></ol><h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h3><p>在Java程序中，多态性是值不同的类对象调用同一个签名的成员方法时，将会执行不同的代码段的现象。<br>实现多态的步骤：</p><ol><li>在子类中覆盖父类的成员方法</li><li>定义父类的对象引用，并由它引用创建的父类对象。</li></ol><p>示例代码：</p><pre><code>public class Main {    public static void main(String[] args) {        A class1 = new A();        A class2 = new B();        System.out.println(&quot;class1: a=&quot; + (class1).a);        System.out.println(&quot;class2: a=&quot; + ((B) class2).a);        class1.fun();        class2.fun();    }}class A {    public int a = 0;    public void fun() {        System.out.println(&quot;---A----&quot;);    }}class B extends A {    public int a =1;    public void fun() {        System.out.println(&quot;----B----&quot;);    }}</code></pre><h2 id="三-抽象类"><a href="#三-抽象类" class="headerlink" title="三. 抽象类"></a>三. 抽象类</h2><blockquote><p>抽象类是对一种概念事物的抽象，将其设置为抽象类的原因就是他不是一个具体的事物，Java程序需要限制直接创建这个类的对象。</p></blockquote><ul><li><strong>语法</strong></li></ul><p>在Java语言中，抽象类就是用abstract修饰符定义的类，其格式为：</p><pre><code>[修饰符] abstract class 抽象类名 {    //  成员变量与成员方法}</code></pre><ul><li><strong>注意事项</strong></li></ul><ol><li>任何包含抽象方法的类必须声明为抽象类</li><li>多态性：抽象类不能被实例化，但是可以创建抽象类的应用，然后用它引用子类该抽象类的某个可以实例化的子类的对象</li><li>抽象类必须被子类继承，且子类必须实现父类的抽象方法</li><li>static、private和final修饰符布鞥应用与抽象方法中 </li></ol><h2 id="四-接口"><a href="#四-接口" class="headerlink" title="四. 接口"></a>四. 接口</h2><blockquote><p>在Java中，接口就是一种特殊的抽象类，其特性在于：<strong>接口的内部只允许包含常量和抽象方法</strong>。常量默认为<code>public static final</code>,抽象方法默认我<code>public abstract</code>。<br><strong>使用接口的目的是统一公共常量、规范公共的操作接口的管理，提高了代码的重用。</strong></p></blockquote><ul><li><p>接口定义</p><pre><code>[修饰符] interface 接口名 {  public static final int a = 0;       //常量  public abstract 返回值 方法名();    //抽象方法}</code></pre></li><li><p>实现接口</p><pre><code>[修饰符] class 类名 implements 接口名 {  //实现抽象方法}</code></pre><h2 id="五-包"><a href="#五-包" class="headerlink" title="五. 包"></a>五. 包</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><blockquote><p>在Java语言中，<strong>包</strong>是用于组织类和接口的机制。</p></blockquote></li></ul><p>按照功能将类与接口分装在不同的包中有两点好处：</p><ol><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用，同时便于将若干个已存在的类或接口整体的加载到一个程序中</li><li>避免出现名字冲突的现象(不同包中的文件名可以相同) </li><li>包也限定了访问权限，拥有包访问权限的类才能访问某个包的类</li></ol><ul><li><strong>包的语法格式</strong></li></ul><pre><code>package net.java.util;public class Something{   ...}</code></pre><p>保存路径： <code>net/java/util/Something.java</code></p><h3 id="2-包的创建与导入方式"><a href="#2-包的创建与导入方式" class="headerlink" title="2. 包的创建与导入方式"></a>2. 包的创建与导入方式</h3><p>创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。<br>例子：</p><pre><code>/* 文件名: Animal.java */package animals;interface Animal {   public void eat();   public void travel();}</code></pre><p>接下来在同一个包中加入该接口的实现：</p><pre><code>package animals;/* 文件名 : MammalInt.java */public class MammalInt implements Animal{   public void eat(){      System.out.println(&quot;Mammal eats&quot;);   }   public void travel(){      System.out.println(&quot;Mammal travels&quot;);   }    public int noOfLegs(){      return 0;   }   public static void main(String args[]){      MammalInt m = new MammalInt();      m.eat();      m.travel();   }}</code></pre><h3 id="3-import关键字"><a href="#3-import关键字" class="headerlink" title="3. import关键字"></a>3. import关键字</h3><p>为了能够使用某一个包的成员，Java提供了“import”语句导入使用包的成员。其语法格式为：</p><pre><code>import package1[.package2…].(classname|*);</code></pre><h3 id="4-package的目录结构"><a href="#4-package的目录结构" class="headerlink" title="4. package的目录结构"></a>4. package的目录结构</h3><p>类放在包中会有两种主要的结果：</p><ul><li>包名成为类名的一部分</li><li>包名必须与响应的字节码所在的目录结构相吻合<br>下面就是管理java文件的一种方式：<br>将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类的名字，并以.java作为扩展名。例如：</li></ul><pre><code>// 文件名 :  Car.javapackage vehicle;public class Car {   // 类实现  }</code></pre><p>接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。</p><pre><code>....\vehicle\Car.java</code></pre><p>现在，正确的类名和路径将会是如下样子：<br>类名 -&gt; vehicle.Car<br>路径名 -&gt; vehicle\Car.java (在 windows 系统中)</p><p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名，如：互联网域名为baidu.com，所有的包名都以com.baidu开头。包名中的每一个部分对应一个子目录。</p><ol><li><p>例如:有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：<code>....\com\runoob\test\Runoob.java</code>编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类的名字，并加上 .class 作为扩展后缀。 例如：</p><pre><code>// 文件名: Runoob.javapackage com.runoob.test;public class Runoob { }class Google {     //类体 }</code></pre></li><li><p>现在，用-d来编译这个文件,如下：</p><pre><code>$javac -d . Runoob.java</code></pre></li><li><p>这样就会像下面这样放置编译了的文件：</p><pre><code>.\com\runoob\test\Runoob.class.\com\runoob\test\Google.class</code></pre></li><li><p>然后就可以像下面这样导入所有\com\runoob\test\ 中定义的类、接口等：</p><pre><code>import com.runoob.test.*;</code></pre></li><li><p>编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。</p><pre><code>&lt;path-one&gt;\sources\com\runoob\test\Runoob.java&lt;path-two&gt;\classes\com\runoob\test\Google.class</code></pre></li><li><p>这样，就可以将类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到程序中使用的所有类型。<br>类目录的绝对路径叫做 <code>class path</code>。设置在系统变量 <code>CLASSPATH</code>中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。<br><code>&lt;path- two&gt;\classes</code> 是 <code>class path</code>，<code>package</code> 名字是 <code>com.runoob.test</code>,而编译器和 JVM 会在 <code>&lt;path-two&gt;\classes\com\runoob\test</code>中找 .class 文件。<br>一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。</p></li></ol><h3 id="5-设置CLASSPATH系统变量"><a href="#5-设置CLASSPATH系统变量" class="headerlink" title="5. 设置CLASSPATH系统变量"></a>5. 设置CLASSPATH系统变量</h3><p><strong>用下面的命令显示当前的CLASSPATH变量：</strong></p><ul><li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH</li><li>UNIX 平台（Bourne shell 下）：# echo $CLASSPATH</li></ul><p><strong>删除当前CLASSPATH变量内容：</strong></p><ul><li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH=</li><li>UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH</li></ul><p><strong>设置CLASSPATH变量:</strong><br>Windows 平台（DOS 命令行下）：<code>C:\&gt; set CLASSPATH=C:\users\jack\java\classes</code><br>UNIX 平台（Bourne shell 下）：<code># CLASSPATH=/home/jack/java/classes; export CLASSPATH</code></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼——类与对象</title>
      <link href="/2019/04/02/yao-dian-ti-lian-lei-yu-dui-xiang/"/>
      <url>/2019/04/02/yao-dian-ti-lian-lei-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="一-类"><a href="#一-类" class="headerlink" title="一. 类"></a>一. 类</h2><h3 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1. 类的定义"></a>1. 类的定义</h3><p>在Java中，类是一种引用型数据类型。类是一种现实世界的事物的抽象，它包含了事物的<strong>属性</strong>和<strong>行为</strong><a href></a>,对应类中的<strong>属性</strong>和<strong>方法</strong><br>java语言的类的格式：</p><pre><code> [修饰符] class 类名 {    类体 }</code></pre><pre><code>public class Dog{   String breed;   int age;   String color;   void barking(){   }   void hungry(){   }   void sleeping(){   }}</code></pre><blockquote><p>在Java语言中，Java的所用东西都要在类中实现。</p></blockquote><h3 id="2-类体"><a href="#2-类体" class="headerlink" title="2. 类体"></a>2. 类体</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>一个类中可以包含以下类型变量</p><ul><li><strong>局部变量：</strong>在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量：</strong>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量：</strong>类变量也声明在类中，方法体之外，但必须声明为static类型。</li></ul><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>类中设置的方法，Java建议类的成员方法的修饰符使用<code>private</code>。Java在调用方法的时候可以用类的实例化对象调用方法,如：<code>new 类名().方法名()</code></p><ul><li><strong>实例方法:</strong> </li></ul><pre><code>[修饰符] 返回值类型 成员方法名（参数列表）[throws 异常类型列表] {     成员方法体}</code></pre><ul><li><p><strong>成员方法的重载</strong><br>所谓的成员方法的重载是指在一个类中，同一个名称的成员方法可以被多次定义的现象，在每一个方法的参数类型和个数都不同。</p></li><li><p><strong>构造方法</strong><br>构造方法是在构造类的对象是使用的方法，其主要的作用就是初始化成员变量。构造方法不需要返回任何值，它在构造类对象时自动调用。构造方法也可以重载。注意：构造方法名和类名必须相同。</p><pre><code>[修饰符] 类名(参数列表)</code></pre></li></ul><p>通常一个类中应该包含的成员方法：</p><ul><li><strong>构造方法：</strong>至少包含一个不带参数的构造方法与一个带完整参数的构造方法</li><li><strong>更改器：</strong>可以保证在对象创建之后，可以更改对象的状态</li><li><strong>获取器：</strong>可以保证随时获得对象的状态值</li><li><strong>toString：</strong>将对象的状态值转换为字符串</li><li><strong>equals：</strong>实现判断两个对象是否相等</li></ul><h3 id="3-类之间的关系"><a href="#3-类之间的关系" class="headerlink" title="3. 类之间的关系"></a>3. 类之间的关系</h3><blockquote><p>类之间的关系可以归结为3类：依赖、聚合和继承</p></blockquote><ul><li>依赖：A类成员方法调用B类的成员方法</li><li>聚合：类A的对象包含类B的对象</li><li>继承：类A继承于类B，即类B中有类A的全部成员变量和成员方法</li></ul><h2 id="二-对象"><a href="#二-对象" class="headerlink" title="二. 对象"></a>二. 对象</h2><blockquote><p>对象是类的一个实例，有状态和行为。</p></blockquote><h3 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1. 创建对象"></a>1. 创建对象</h3><ul><li>定义对象的语法格式：</li></ul><pre><code>[修饰符] 类名 对象名;Data data;</code></pre><ul><li>创建对象</li></ul><pre><code>new 类名(参数列表);new Data(10);</code></pre><ul><li>定义创建对象也可以放在一起进行</li></ul><pre><code>Time time = new Time(10);</code></pre><p><strong>new运算符主要完成两项工作：</strong></p><ol><li>为对象分配内存空间</li><li>根据提供的参数格式调用与之匹配的构造方法，实现初始化成员变量的操作，然后返回对象的引用</li></ol><h3 id="2-对象成员的引用"><a href="#2-对象成员的引用" class="headerlink" title="2. 对象成员的引用"></a>2. 对象成员的引用</h3><pre><code>对象名.成员变量;对象名.成员方法(参数列表)</code></pre><h3 id="3-对象的清除"><a href="#3-对象的清除" class="headerlink" title="3. 对象的清除"></a>3. 对象的清除</h3><p>在Java中，对象的收回是通过Java虚拟机自动收回的，不用我们操心。</p><h2 id="三-访问特性控制"><a href="#三-访问特性控制" class="headerlink" title="三. 访问特性控制"></a>三. 访问特性控制</h2><blockquote><p>Java语言是通过控制标识符来控制类、数据、方法和接口的共享的，Java提供了四种访问特性控制符：</p><ol><li>默认访问特性</li><li>public（公有）访问特性</li><li>private （私有）访问特性</li><li>protected （保护）访问特性</li></ol></blockquote><h3 id="1-默认访问特性"><a href="#1-默认访问特性" class="headerlink" title="1. 默认访问特性"></a>1. 默认访问特性</h3><p>如果在定义类、接口、成员变量与成员方法时没有定义访问特性，那么Java默认他的访问特性为默认访问特性。具有默认访问特性的类、接口、成员变量与成员方法，只能被本类和同一个包中的其他类、接口接成员方法应用。（他可以阻止其他包任何形式的引用。）</p><h3 id="2-public访问特性"><a href="#2-public访问特性" class="headerlink" title="2. public访问特性"></a>2. public访问特性</h3><p>public访问特性最具有开放性，没有任何访问限制。<br>通常会将公共类或者作为公共接口的的成员方法指定为public访问特性；建议不要将成员变量设置为public，否则会破坏代数据的隐藏性。</p><h3 id="3-private访问特性"><a href="#3-private访问特性" class="headerlink" title="3. private访问特性"></a>3. private访问特性</h3><p>将数据与操作封装在一起，并将数据的组织隐藏起来，利用成员方法作为对外的操作接口。这样不当可以提高程序的安全性和可靠性，还有有益于日后的维护、扩展和重用。<br>这种访问特性实现数据隐藏的最佳方式。<br>应用于类成员。只能被本类直接引用。</p><h3 id="4-protected访问特性"><a href="#4-protected访问特性" class="headerlink" title="4. protected访问特性"></a>4. protected访问特性</h3><p>可以被本类、本包中的其他类和其他包中的子类访问。他的访问特性介于默认和public之间。</p><blockquote><p>小技巧：如何阅读代码<br>作为一个程序员，面对一段从未见识过的代码，不必每行代码都细读（当然，这也不可能，真正的项目里代码有万千行，你自己读读试试），只需要将代码按照结构分成不同段，大致了解每一部分代码的事项的功能即可。比如，一段Java代码，按照类分成不同的部分，基本一段好的程序，从类的名字中就能知道这个类的作用的。</p></blockquote><h2 id="四-内部类"><a href="#四-内部类" class="headerlink" title="四. 内部类"></a>四. 内部类</h2><p>Java的类是允许嵌套的，嵌套在一个类内部的被称为<strong>内部类</strong>。没有嵌套在任何类中的类被称为顶层类。</p><h2 id="五-类的静态成员"><a href="#五-类的静态成员" class="headerlink" title="五. 类的静态成员"></a>五. 类的静态成员</h2><p>Java语言提供了两种形式的成员：</p><ul><li>静态成员</li><li>实例成员（非静态）</li></ul><h3 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h3><ul><li>在分文修饰符之后加上static修饰符就称为静态成员变量。例如：<code>public static int staticMember</code></li><li>静态成员变量值在家在类是创建一个副本，无论未来创建同一个类的多少个对象都将共享同一个副本。</li></ul><h3 id="2-静态成员方法"><a href="#2-静态成员方法" class="headerlink" title="2. 静态成员方法"></a>2. 静态成员方法</h3><h2 id="六-可编辑字符串类"><a href="#六-可编辑字符串类" class="headerlink" title="六. 可编辑字符串类"></a>六. 可编辑字符串类</h2><p>可编辑的字符串类：StringBuffer<br>StringBuffer类滴哦你故意在java.lang包中，其中包含以下3个private成员变量</p><ul><li>private char value[]：存放字符串的缓冲区</li><li>private int count：缓冲区中存放字符的个数</li><li>private boolean shared：缓冲区是否共享的标志</li></ul><p>另外，另外还提供了3个构造方法：</p><ul><li>public stringBuffer();  默认缓冲区的大小为16个字符</li><li>public stringBuffer(int length); 缓冲区的大小为length个字符</li><li>public stringBuffer(String str); 缓冲区的大小为字符串str的长度加上16，并将str存入缓冲区</li></ul><p><strong>StringBuffer用于获取可变字符串相应信息的public成员方法：</strong></p><ol><li>ing length() 返回当前可变字符床的长度</li><li>int capacity() 放回当前缓冲区的大小</li><li>char charAt(int index） 返回下标为index的位置的字符串，第一个字符的下标为0.（如果index非法将抛出IndexOutOfBoundsException异常）</li><li>void getChars(int sreBegin, int srcEnd, char dst[], int destBegin) 获取从sreBegin到srcEnd的字符串，并存入dst数组中，在dst中的起始位置为dstBegin。如果srcBegin和srcEnd非法将抛出StringIndexOutOfBoundsException异常</li><li>String substring(int start, int end) 返回从start到end的字符串</li><li>int indexOf(String str, int fromIndex) 返回字符串str在缓冲区从fromIndex开始，第一次出现的手字符的下标。</li><li>String toString(）将StringBuffer内容转换成String形式输出</li><li>void setChar(int index, char ch)将字符串中下标为index的字符设置为ch</li><li>StringBuffer append(obj) 这个成员方法利用String类中的ValueOf(）方法，将obj转换成字符串，并将这些字符串追加到缓冲区的尾部</li><li>StringBuffer delete(int start，int end) 删除缓冲区start到end的所有字符</li><li>StringBuffer replace(int start, int end, String str）将str字符串替换从start～end-1 的字符串并返回修改后的StringBuffer对象</li><li>StringBuffer insert(int index, char str[], int offset, int len) 将str数组从0ffset开始，长度为len的字符串插入到缓冲区从index起始的位置处</li><li>StringBuffer inset(int offset, Object obj) 将obj字符串插入到缓冲区偏移量为offset的位置处。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渝中召开领导干部大会 传达学习陈敏尔书记参加渝中代表团审议时的讲话精神</title>
      <link href="/2019/03/26/yu-zhong-zhao-kai-ling-dao-gan-bu-da-hui/"/>
      <url>/2019/03/26/yu-zhong-zhao-kai-ling-dao-gan-bu-da-hui/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/OHD6z6fDlM9822fpn79tIribC0iaaH1QkzDAX4klv2ePEm8FsXkiatrChPP3NnrjLmngQ88zL0YIJc9DqamF6icseA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt></p><blockquote><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2kfkimtj30u00gwkfp.jpg" alt><br>今（1）日，渝中召开领导干部大会，传达学习市委书记陈敏尔在参加渝中代表团审议时的讲话精神。渝中区委书记黄玉林出席会议并讲话，区委副书记、区长商奎，区人大常委会主任米绍林，区政协主席陈大奎，区委副书记何家利以及全体在家区级领导，全区正处级以上领导干部参加会议。</p></blockquote><blockquote><p>黄玉林指出，陈敏尔书记到渝中代表团参加审议，是对渝中工作的关心和厚爱，是对全区干部群众凝心聚力、砥砺奋进推进高质量发展、创造高品质生活的有力鞭策。全区上下一定要认真学习领会、深入贯彻落实陈敏尔书记参加渝中代表团审议时的讲话精神，全力以赴推动市委要求在渝中落实落地。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2l3w53ij30u00gw4hn.jpg" alt><br>黄玉林强调，要深刻领会把握陈敏尔书记关于“紧紧围绕习近平总书记对重庆提出的重要指示要求，进一步提高政治站位和战略站位，增强战略谋划力、战役执行力”的指示精神，把准方向保持定力，确保中央要求和市委部署率先在渝中落地生根、开花结果。要自觉维护习近平总书记党中央的核心、全党的核心地位，维护党中央权威和集中统一领导，牢固树立“四个意识”，坚定“四个自信”，以实际行动兑现市委“三个确保”的政治承诺。要深学笃用习近平新时代中国特色社会主义思想，把总书记对重庆的殷殷嘱托领会好，始终沿着总书记指引的方向前进。要按照陈敏尔书记“学在深处、谋在新处、干在实处、走在前列”要求，把总书记对重庆提出的“两点”定位、“两地”“两高”目标和营造良好政治生态、做到“四个扎实”的重要指示要求，落实为渝中行动，转化为实在成效。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2m4y131j30u00mi1kx.jpg" alt><br>黄玉林强调，要深刻领会把握陈敏尔书记关于“把构建现代产业体系作为城市发展的重要支撑”的指示要求，坚定方向突出重点，创新发展金融业，优化发展高端商贸业，融合发展文化旅游业，升级发展康养产业，用好优势医疗、教育资源，推动现代服务业创新升级发展。要深刻领会把握陈敏尔书记“大力推进社会治理现代化，贯彻以人民为中心的发展思想，让人民群众在城市生活更方便、更舒心、更美好”的指示要求，夯实基层强化基础，把安全放在城市管理服务第一位，增强城市管理服务的人文关怀，创新城市管理服务方式方法，全面提高城市管理服务水平。要深刻领会把握陈敏尔书记对渝中经济社会发展成绩的肯定，增强信心坚定决心，把市委市政府对渝中的肯定转化为发展的强大动力，牢记中心城区职责使命不动摇，顺应城市工作新形势、改革发展新要求、人民群众新期待，不断奋发有为、担当作为，着力打造适应服务业发展现代化和社会治理现代化要求的高素质干部队伍，凝聚起推动渝中高质量发展的强大合力。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼——数组与字符串</title>
      <link href="/2019/03/26/yao-dian-ti-lian-shu-zu-yu-zi-fu-chuan/"/>
      <url>/2019/03/26/yao-dian-ti-lian-shu-zu-yu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h2><h3 id="1-1-一维数组"><a href="#1-1-一维数组" class="headerlink" title="1.1 一维数组"></a>1.1 一维数组</h3><h4 id="1-一维数组的声明方法："><a href="#1-一维数组的声明方法：" class="headerlink" title="1. 一维数组的声明方法："></a>1. 一维数组的声明方法：</h4><pre><code>int[] a = new int[n];   //表示a[]是有n个元素的整形数组</code></pre><p><strong>强制：声明数组时,强制[]放在基本数据类型后面，不要放在变量后面。放在基本数据类型后面表示声明一个int类型的数组。</strong></p><h4 id="2-一维数组初始化："><a href="#2-一维数组初始化：" class="headerlink" title="2. 一维数组初始化："></a>2. 一维数组初始化：</h4><ul><li><strong>静态初始化</strong>：<code>int[] a = {1,2,3,4};</code></li><li><strong>动态初始化</strong>：<code>a[0] = 3;</code></li></ul><h4 id="3-一维数组元素的访问："><a href="#3-一维数组元素的访问：" class="headerlink" title="3. 一维数组元素的访问："></a>3. 一维数组元素的访问：</h4><p>数组的元素是通过索引访问的。数组索引从0开始，所以索引值从0到arrayRefVar.length-1。</p><pre><code>a[index]; //其中index为数组下标，表示数组中第index-1个存储空间。</code></pre><h3 id="1-2-二维数组"><a href="#1-2-二维数组" class="headerlink" title="1.2 二维数组"></a>1.2 二维数组</h3><h4 id="二维数组声明方法："><a href="#二维数组声明方法：" class="headerlink" title="二维数组声明方法："></a>二维数组声明方法：</h4><pre><code>int[][] a = new int[m][n];  //m，n为数组下标</code></pre><h4 id="数组初始化："><a href="#数组初始化：" class="headerlink" title="数组初始化："></a>数组初始化：</h4><ul><li><strong>静态初始化：</strong></li></ul><pre><code>int[][] a = {             {1,2,3},             {4,5,6},             {7,8,9}};</code></pre><ul><li><strong>动态初始化：</strong></li></ul><pre><code>int[][] a = new int[m][n]; a[0][1] = 4;   //动态的分别给字符串的每一个元素赋值</code></pre><h4 id="二维数组的访问："><a href="#二维数组的访问：" class="headerlink" title="二维数组的访问："></a>二维数组的访问：</h4><p>二维数组的访问和一维数组的访问类似</p><h2 id="2、字符串"><a href="#2、字符串" class="headerlink" title="2、字符串"></a>2、字符串</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2019/03/21/yao-dian-ti-lian-java-ji-chu/"/>
      <url>/2019/03/21/yao-dian-ti-lian-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JAVA基本语法"><a href="#1-JAVA基本语法" class="headerlink" title="1. JAVA基本语法"></a>1. JAVA基本语法</h2><p>编写Java程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass(驼峰命名法) 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写（驼峰命名法）。</li><li><strong>源文件名</strong>：<strong>源文件名必须和类名相同</strong>。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>主方法入口</strong>：所有的Java程序由<code>public static void main(String args[])</code>方法开始执行。</li></ul><h2 id="2-JAVA编程格式"><a href="#2-JAVA编程格式" class="headerlink" title="2. JAVA编程格式"></a>2. JAVA编程格式</h2><pre><code>import java.util.Scanner;public class Main {    public static void main(String[] args) throws Exception{        System.out.println(config.a + config.b);        Scanner in = new Scanner(System.in);        int a = in.nextInt();        System.out.println(a);    }}</code></pre><h2 id="3-JAVA数据类型"><a href="#3-JAVA数据类型" class="headerlink" title="3. JAVA数据类型"></a>3. JAVA数据类型</h2><h3 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h3><p>byte、char、short、int、long、float、double、boolean</p><table><thead><tr><th>数据类型</th><th>类别</th><th>位数</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>8位</td><td>-2^7 ～ 2^7-1</td><td>0</td></tr><tr><td>char</td><td>字符型</td><td>16位</td><td>\u0000 ～ \uffff (0~65535)</td><td>0</td></tr><tr><td>short</td><td>短整型</td><td>16位</td><td>-2^15 ～ 2^15-1</td><td>0</td></tr><tr><td>int</td><td>整型</td><td>32位</td><td>-2^31 ～ 2^31-1</td><td>0</td></tr><tr><td>long</td><td>长整型</td><td>64位</td><td>-2^63 ～ 2^63-1</td><td>0L</td></tr><tr><td>float</td><td>单精度浮点型</td><td>32位</td><td>-3.4 X 10^38 ～ 3.4 X 10^38</td><td>0.0f</td></tr><tr><td>double</td><td>双精度浮点型</td><td>64位</td><td>-1.7 X 10^308 ～ 1.7 X 10^308</td><td>0.0d</td></tr><tr><td>boolean</td><td>布尔类型</td><td></td><td>true、false</td><td>false</td></tr></tbody></table><h3 id="3-2-数据类型转换规则"><a href="#3-2-数据类型转换规则" class="headerlink" title="3.2 数据类型转换规则"></a>3.2 数据类型转换规则</h3><p>JAVA中的数据类型在定义时就已经确定了，不能随意改变。但是JAVA允许有限度的进行类型转换处理：<strong>自动类型转换</strong>、<strong>强制类型转换</strong><br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1arnl1y66j315q0nowgk.jpg" alt></p><h4 id="3-2-1-自动类型转换"><a href="#3-2-1-自动类型转换" class="headerlink" title="3.2.1 自动类型转换"></a>3.2.1 自动类型转换</h4><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1fvxqrpgtj32xj16mx6t.jpg" alt></p><h4 id="3-2-2-强制类型转换"><a href="#3-2-2-强制类型转换" class="headerlink" title="3.2.2 强制类型转换"></a>3.2.2 强制类型转换</h4><p>将高级数据转换成低级数据，只能用强制类型转换，通常在要求强制类型转换的变量名前用()括号上所要强制转换的类型符号。如：</p><pre><code>short s；byte b = (byte)s;</code></pre><h2 id="4-直接量、常量与变量"><a href="#4-直接量、常量与变量" class="headerlink" title="4. 直接量、常量与变量"></a>4. 直接量、常量与变量</h2><ul><li><strong>直接量</strong>：就是数据类型的数值，如int型：3就是直接量</li><li><strong>常量</strong>：特定标识符表示的直接量，赋值之后就不可以更改：<pre><code>[修饰符] final 数据类型 常量标识符 [= 直接量]public final int a = 3;</code></pre></li><li><strong>变量</strong>：存储数据的特定标识符，可以更改存储的数据：<pre><code>数据类型 常量标识符 [= 直接量]int a = 3;</code></pre></li></ul><h2 id="5-JAVA的输入输出方式"><a href="#5-JAVA的输入输出方式" class="headerlink" title="5. JAVA的输入输出方式"></a>5. JAVA的输入输出方式</h2><ul><li><strong>输入</strong>：Java的输入是通过Scanner类实现的，在时用Scanner类时要在项目最顶端倒入Scanner类，如：import java.util.Scanner;</li></ul><pre><code>Scanner scan = new Scanner(System.in) // System.in是系统的System类的输入流int a = scan.nextInt();</code></pre><p>nextInt是Scanner类的一个读取数据的成员方法。Scanner类内部定义了许多的成员方法用于读取不同数据类型的数据：<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1fxdwk2kvj32zn1f2qvb.jpg" alt></p><ul><li><strong>输出</strong>：Java的最简单的输出方式：<pre><code>System.out.print(&quot;Hello World:&quot; + a);</code></pre><strong>注意“+”</strong>：+在里面充当连接符的角色，但是当两个基本数据类型的变量被+连接时，他们会进行加操作；字符串和数据类型变量被+连接时，数据类型变量会自动转换成字符串。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼-View的事件体系</title>
      <link href="/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/"/>
      <url>/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/</url>
      
        <content type="html"><![CDATA[<p><strong>View是Android中的所有控件的基类，所有的控件都是直接或间接继承自View，所以View在Android中是一个很重要的概念。本篇将简要介绍View。<br>内容如下：</strong></p><ul><li>Android UI界面架构</li><li>View的基础知识</li><li>View的滑动</li><li>弹性滑动</li><li>View的事件分发机制</li><li>View的滑动冲突</li></ul><hr><h3 id="一、Android-UI界面架构"><a href="#一、Android-UI界面架构" class="headerlink" title="一、Android UI界面架构"></a>一、Android UI界面架构</h3><p>讲View之前先涉及一点Android的UI结构，后面的View分发机制会涉及一点这里的知识。<br>每个Activity包含一个<code>PhoneWindow</code>对象，<code>PhoneWindow</code>设置<code>DecorView</code>为应用的根视图（顶级视图）。在里面就是我们熟悉的<code>TitleView</code>和<code>ContentView</code>。<code>titleView</code>的位置就是我们那平常看到的App的标题栏，而我们平时在Activit中使用的<code>setContentView（）</code>就是设置<code>ContentView</code>。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrn2iri7j30ve0g0k2g.jpg" alt></p><h3 id="二、View的基础知识"><a href="#二、View的基础知识" class="headerlink" title="二、View的基础知识"></a>二、View的基础知识</h3><h4 id="1、什么是View"><a href="#1、什么是View" class="headerlink" title="1、什么是View"></a>1、什么是View</h4><p><strong>View：</strong>它是一种界面层的控价的一种抽象，它代表了一个控价。Android中的所有的控件都继承自它。<br><strong>ViewGroup：</strong>顾名思义这是一个View的组合，它内部包含了多个View。ViewGroup也继承了View，这就意味着View本身就可以是单个控件也可以是多个控价组成的一组控件。<br>从某种角度讲，Android中的控价可以分为两大类：View和ViewGroup。通过ViewGroup，整个界面可以组成一个View树，上层的View要负责下层View的测量与绘制，并传递事件。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrnrvi8aj30j60b3dj1.jpg" alt></p><h4 id="2、View的位置参数"><a href="#2、View的位置参数" class="headerlink" title="2、View的位置参数"></a>2、View的位置参数</h4><p>a. Android坐标系：以屏幕左上角为坐标原点，<strong>向右</strong>为x轴正方向，<strong>向下</strong>为y轴正方向。<br>b. View的位置主要由它的四个顶点决定：top、left、right、bottom</p><ul><li>top：左上角的纵坐标</li><li>left：左上角的横坐标</li><li>right：右下角的横坐标</li><li>bottom：右下角的纵坐标<br><strong>这些都是相对于View的父容器而言的，是一种相对坐标</strong><br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zro3hdndj30c50bkq42.jpg" alt><br>由上图就很容易的得到View的宽高和坐标的关系：<pre><code>width = right - leftheight = bottom - top</code></pre>我们了解了上述View属性，那我们怎么获取这些属性呢。别着急，其实View还提供了get方法帮助我们获取上述属性。</li><li>left = getLeft()</li><li>Right = getRight()</li><li>top = getTop()</li><li>bottom = getBottom</li><li>width = getWidth</li><li>height = getHeight</li></ul><p>c.从Android3.0开始，View增加了额外的几个参数：x、y、translationX、translationY。<br>其中x和y是View左上角的坐标，translationX和translationY是View的左上角相对于父容器的偏移量，他们的默认值均为0。和View的基本属性一样，这些参数也是相对于View父容器的，而且View也提供了set/get方法。</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zroc04s9j30kl0hd788.jpg" alt></p><blockquote><p>x = left + translationX<br>y = top + translationY</p></blockquote><p><strong>注意：</strong> View在移动的过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x、y、translationX和translationUY这四个参数。另外在onCreate()方法里面无法获取到View的坐标参数，这是因为此时的View还未开始绘制，全部的坐标参数都将是0。</p><h4 id="3-MotionEvent和TouchSlop"><a href="#3-MotionEvent和TouchSlop" class="headerlink" title="3. MotionEvent和TouchSlop"></a>3. MotionEvent和TouchSlop</h4><h5 id="1-MotionEvent"><a href="#1-MotionEvent" class="headerlink" title="1.MotionEvent"></a>1.MotionEvent</h5><p>在手指接触屏幕后所产生的一系列的事件，典型的事件类型有：</p><ul><li>ACTION_DOWN -—— 手指接触屏幕</li><li>ACTION_MOVE -—— 手指在屏幕上移动</li><li>ACTION_UP ———— 手指从屏幕上松开的一瞬间<br>正常情况下，一次手指接触屏幕的行为就会触发一系列的事件，列出两种典型情况：</li><li>点击屏幕后松开：ACTION_DOWN -&gt; ACTION_UP</li><li>点击屏幕后滑动一段距离松开：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_UP</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5494434-1fe5babc389caa90?imageMogr2/auto-orient/" alt></p><p><strong>在Android中所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、历史记录、第几个手指等，所以我们可以通过MotionEvent对象来得到点击事件的x和y坐标。为此系统提供了两组方法：getX/getY和getRawX/getRawY。</strong></p><ul><li>getX/getY: 返回相当于当前View左上角的坐标</li><li>getRawX/getRawY: 放回对于手机屏幕左上角的坐标 </li></ul><p>具体关系如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5494434-825bc5992190e5e8?imageMogr2/auto-orient/" alt></p><h5 id="2-TouchSlop"><a href="#2-TouchSlop" class="headerlink" title="2. TouchSlop"></a>2. TouchSlop</h5><p>TouchSlops是系统所能识别出来的滑动的最小的距离。即这是一个常量，当手机在屏幕上的滑动距离小于这个常量的时候，系统就不会认为这是一个滑动操作。这个常量和设备有关，在不同的设备上有不同的值，我们可以通过<code>ViewConfiguration.get(get(context)).getScaledTouchSlop()</code>获取到这个常量。</p><h4 id="4-VelocityTracker、GestureDetector和Scroller"><a href="#4-VelocityTracker、GestureDetector和Scroller" class="headerlink" title="4. VelocityTracker、GestureDetector和Scroller"></a>4. VelocityTracker、GestureDetector和Scroller</h4><h5 id="1-VelocityTracker"><a href="#1-VelocityTracker" class="headerlink" title="1. VelocityTracker"></a>1. VelocityTracker</h5><p>–速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。<br>使用过程：首先在View的<code>onTouchEvent</code>方法中追踪当前事件的速度：</p><pre><code>VelocityTracker mVelocityTracker = VelocityTracker.obtain();mVelocityTracker.addMovement(event);</code></pre><p>接着，在<strong>ACTION_MOVe</strong>事件中获取当前的速度：</p><pre><code>mVolocityTracker.computeCurrenVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity();float yXelocity = mVelocityTracker.getYVelocity();</code></pre><p>最后，当不需要使用它是，需要调用clear方法来重置并回收内存：</p><pre><code>mVelocityTracker.clear();mVelocityTracker.recycle();</code></pre><p><strong>注意这里计算的速度值为1000ms时间间隔移动的像素值，假设移动了100像素，速度就是100像素/秒</strong></p><h5 id="2-GestureDetector"><a href="#2-GestureDetector" class="headerlink" title="2. GestureDetector"></a>2. GestureDetector</h5><p>–手势检测。用于辅助检测用户的点击、滑动、长按、双击等行为。<br>使用过程：<br>创建一个<code>GestureDetector</code>对象并实现<code>onGestureLister</code>接口，根据需要是想点击方法：</p><pre><code>GestureDetector mGestureDetector = new GestureDetector(this);mGestureDetector.setIsLongpressEnabled(false);  //解决长按屏幕后无法实现拖动的现象</code></pre><p>接着，接管目标<code>View</code>的<code>onTouchEvent</code>方法，在待监听View的<code>onTouchEvent</code>方法中添加如下实现：</p><pre><code>boolean consume = mGestureDetector.onTouchEvent(event);return consume;</code></pre><p>做完上面两步我们就可以有选择的实现OnGestureListener和OnDoubleTapListener中的方法了,OnGestureListener和OnDoubleTapListener接口中的方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>所属接口</th></tr></thead><tbody><tr><td>onDown</td><td>手指轻轻接触屏幕的一瞬间，只有一个ACTION_DOWN</td><td>OnGestureListener</td></tr><tr><td>onShowPress</td><td>手指轻轻触摸屏幕，尚未松开或拖动， 由1个ACTION_DOWN触发</td><td>OnGestureListener</td></tr><tr><td>onSingleTopUp</td><td>手指（轻轻触摸屏幕后）松开，伴随着一个ACTION_UP触发（这是点击行为）</td><td>OnGestureListener</td></tr><tr><td>onScroll</td><td>手指按下屏幕并拖动，由1个ACTION_DOWN和多个ACTION_MOVE触发（这是拖动功能）</td><td>OnGestureListener</td></tr><tr><td>onLongPress</td><td>用户长按屏幕</td><td>OnGestureListener</td></tr><tr><td>onFling</td><td>用户触摸屏幕、快速的滑动后松开，由1个ACTION_DOWN、多个ACTION_MOVE和1个ACTION_UP触发，这是快速滑动行为</td><td>OnGestureListener</td></tr><tr><td>onDoubleTap</td><td>双击，由2个ACTION_DOWN触发，他不能和onSingleTapConfirmed共存</td><td>onDoubleTapListener</td></tr><tr><td>onSingleTapConfirmed</td><td>严格的点击行为</td><td>onDoubleTapListener</td></tr><tr><td>onDoubleTapEvent</td><td>表示发生了双击行为，在双击的期间，ACTION_DOWN、ACTION_MOVE、ACTION_UP都会触发次回调</td><td>onDoubleTapListener</td></tr></tbody></table><blockquote><p>在实际开发中可以不使用GestureDetector，完全可以自己在onTouchEvent中实现所需的监听。另外，如果知识监听滑动相关的，建议自己在onGestureDetector中实现，如果要监听双击这种行为的话，就使用GestureDetecter。</p></blockquote><h5 id="3-Scroller"><a href="#3-Scroller" class="headerlink" title="3. Scroller"></a>3. Scroller</h5><p>弹性滑动，用于实现View的弹性滑动。<br>当时使用scrollTo/scrollBy滑动时，滑动是瞬间完成的，这样的滑动效果看起来没有流畅感。这个时候就需要使用Scroller来实现由过渡效果的滑动。Scroller的话送不是瞬间完成的，它是在一定时间间隔内完成的。Scroller本身不能使View滑动，它需要配合View的computeScroll方法才能共同完成View的滑动。下面是一个简单的实现弹性滑动的代码：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();    int delta = destX - scrollX;    //1000ms内滑向destX，效果就是慢慢滑动    mScroller.startScroll(scrollX, 0, delta, 0, 1000);    invalidate();}@Overridepublic void computeScroll() {    if(mScroller.computeScrollOffSet()) {        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());        postInvalidate();    }}</code></pre><h3 id="三、View的滑动"><a href="#三、View的滑动" class="headerlink" title="三、View的滑动"></a>三、View的滑动</h3><blockquote><p><strong>实现View滑动的三种方式：</strong></p><ol><li>通过View本身提供的scrollTo/scrollBy方法</li><li>通过动画给View施加平移效果</li><li>通过改变View的LayoutParams使得View重新布局</li></ol></blockquote><h4 id="1-使用scrollTo-scrollBy"><a href="#1-使用scrollTo-scrollBy" class="headerlink" title="1. 使用scrollTo/scrollBy"></a>1. 使用scrollTo/scrollBy</h4><p>为了实现View的滑动，Vie提供了专门的方法实现这个功能：scrollTo和scrollBy<br><strong>scrollTo()</strong>:在当前视图内容偏移至(x , y)坐标处，即显示(可视)区域位于(x , y)坐标处。</p><pre><code>/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */    public void scrollTo(int x, int y) {        //偏移位置发生了改变        if (mScrollX != x || mScrollY != y) {              int oldX = mScrollX;            int oldY = mScrollY;            mScrollX = x;  //赋新值，保存当前便宜量            mScrollY = y;            //回调onScrollChanged方法            onScrollChanged(mScrollX, mScrollY, oldX, oldY);            if (!awakenScrollBars()) {                invalidate();  //一般都引起重绘            }        }    }</code></pre><p><strong>scrollBy():</strong>：在当前视图内容继续偏移(x , y)个单位，显示(可视)区域也跟着偏移(x,y)个单位。</p><pre><code> /**       * Move the scrolled position of your view. This will cause a call to       * {@link #onScrollChanged(int, int, int, int)} and the view will be       * invalidated.       * @param x the amount of pixels to scroll by horizontally       * @param y the amount of pixels to scroll by vertically       */      // 看出原因了吧 。。 mScrollX 与 mScrollY 代表我们当前偏移的位置 ， 在当前位置继续偏移(x ,y)个单位      public void scrollBy(int x, int y) {          scrollTo(mScrollX + x, mScrollY + y);      }</code></pre><p><strong>总结:scrollTo()指的是移动到制定的(x,y)位置，而scrollBy(x,y)指的是，在当前位置在移动(x,y)个位置</strong></p><p>mScrollX和mScrollY分别表示View在X、Y方向的滚动距离。mScrollX：View的左边缘减去View的内容的左边缘；mScrollY：View的上边缘减去View的内容的上边缘。从右向左滑动，mScrollX为正值，反之为负值；从下往上滑动，mScrollY为正值，反之为负值。（更直观感受：查看下一张照片或者查看长图时手指滑动方向为正）</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g10db9qbgdj30jg0dracq.jpg" alt></p><h4 id="2-使用动画"><a href="#2-使用动画" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p> 这节我们讲解如何使用动画来移动View，主要操作是View的<code>translationX</code>和<code>translationY</code>的属性,既可以采用传统的View动画，也可以采用属性动画（如果使用属性动画的话，为了能够兼容3.0以下的版本，需要采用开源动画<code>nineoldandroids</code>(<a href="http://nineoldandroids.com/）" target="_blank" rel="noopener">http://nineoldandroids.com/）</a><br> 采用View动画代码，如下所示。此动画可以在100ms内将一个View从原始位置向右下角移动100个像素。</p><pre><code> &lt;?xml veision=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:fillAfter=&quot;true&quot;    android:zAdjustment=&quot;normal&quot;&gt;    &lt;translate         android:duration=&quot;100&quot;        android:fromXDelta=&quot;0&quot;        android:fromYDelta=&quot;0&quot;        android:interpolator=&quot;@android:anim/linear_interpolator&quot;        android:toXDelata=&quot;100&quot;        android:toYDelata=&quot;100&quot;/&gt;&lt;/set&gt;</code></pre><p> 采用属性动画就更简单了：</p><pre><code> ObjectAnimator.ofFloat(targetView, &quot;translationX&quot;, 0, 100).setDuration(100).start();</code></pre><p>View动画是对View的影像的操作，他并不能真正改变View的参数，包括宽/高，并且如果希望动画移动后的状态保留还必须讲<code>fillAfter</code>属性设置为true。而属性动画并不存在上述的问题，但是在Android3.0以下就不能使用属性动画了。</p><h4 id="3-使用LayoutParams将一个View重新布局"><a href="#3-使用LayoutParams将一个View重新布局" class="headerlink" title="3.使用LayoutParams将一个View重新布局"></a>3.使用LayoutParams将一个View重新布局</h4><p>比如将一个View向右移动100像素，向右，只需要把它的marginLeft参数增大即可，代码见下：</p><pre><code>MarginLayoutParams params = (MarginLayoutParams) btn.getLayoutParams();params.leftMargin += 100;btn.requestLayout();// 请求重新对View进行measure、layout//或btn.setLayoutParams(params);</code></pre><h4 id="4、各种滑动方式的比较"><a href="#4、各种滑动方式的比较" class="headerlink" title="4、各种滑动方式的比较"></a>4、各种滑动方式的比较</h4><ul><li>scrollTo/scrollBy：操作简单适合对View内容的滑动</li><li>动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</li><li>LayoutParams：操作稍微复杂，适合于有交互的View</li></ul><h3 id="四、弹性滑动"><a href="#四、弹性滑动" class="headerlink" title="四、弹性滑动"></a>四、弹性滑动</h3><p>上一节讲了View的滑动，但是这种直接滑动效果实在是太差了，这里我们学习如何实现渐进式滑动。虽然实现的方法有很多，但是基本思想都是一样的：将一次滑动分成若干次小的滑动，并在一定时间内完成。这里介绍三种实现方式：Scroller、Handler#postDelayed以及Thread#sleep。</p><h4 id="1-Scroller"><a href="#1-Scroller" class="headerlink" title="1.Scroller"></a>1.Scroller</h4><blockquote><ul><li>与scrollTo/scrollBy不同：scrollTo/scrollBy过程是瞬间完成的，非平滑；而Scroller则有过渡滑动的效果。</li><li>注意：Scoller本身无法让View弹性滑动，它需要和View的computerScroller方法配合使用。</li></ul></blockquote><p>再看一次Scroller的经典使用方法：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();//View的左边缘到其内容左边缘的距离  int scrollY = getScrollY();//View的上边缘到其内容上边缘的距离  int deltaX = dstX - scrollX;//x方向滑动的位移量  int deltaY = dstY - scrollY;//y方向滑动的位移量  scroller.startScroll(scrollX, scrollY, deltaX, deltaY, 1000); //开始滑动  invalidate(); //刷新界面}@Override//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记public void computeScroll() {  if (scroller.computeScrollOffset()) {     scrollTo(scroller.getCurrX(), scroller.getCurY());    postInvalidate();//通过不断的重绘不断的调用computeScroll方法  }}</code></pre><p>工作原理：当我们构造一个Scroller对象并且调用他的startScroll方法时，Scroller内部其实什么也没有做，他只是保存了我们传递的几个参数，这几个参数从startScroll的源码里就能看出：</p><pre><code>public void startScroll(int startX,int startY,int dx,int dy,int duration){  mMode = SCROLL_MODE;  mFinished = false;  mDuration = duration;//滑动时间  mStartTime = AnimationUtils.currentAminationTimeMills();//开始时间  mStartX = startX;//滑动起点  mStartY = startY;//滑动起点  mFinalX = startX + dx;//滑动终点  mFinalY = startY + dy;//滑动终点  mDeltaX = dx;//滑动距离  mDeltaY = dy;//滑动距离  mDurationReciprocal = 1.0f / (float)mDuration; }</code></pre><blockquote><p><strong>具体过程：</strong>在MotionEvent.ACTION_UP事件触发时调用startScroll方法-&gt;马上调用invalidate/postInvalidate方法-&gt;会请求View重绘，导致View.draw方法被执行-&gt;会调用View.computeScroll方法，此方法是空实现，需要自己处理逻辑。具体逻辑是：先判断computeScrollOffset，若为true（表示滚动未结束），则执行scrollTo方法，它会再次调用postInvalidate，如此反复执行，直到返回值为false。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g110wgux3cj30vw0kq43j.jpg" alt></p><blockquote><p>Scroll的computeScrollOffset()根据时间的流逝动态计算一小段时间里View滑动的距离，并得到当前View位置，再通过scrollTo继续滑动。即把一次滑动拆分成无数次小距离滑动从而实现弹性滑动。</p></blockquote><h4 id="2-使用动画-1"><a href="#2-使用动画-1" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p>动画本身就是一种渐进的过程，因此通过动画来实现滑动天然就有一种弹性效果。</p><pre><code>ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start();//在100ms内使得View从原始位置向右平移100像素</code></pre><p>我们还可以利用动画的特性来实现一些动画无法实现的特效，还拿scrollTo来说,我们想模仿Scroller来实现View的弹性滑动。</p><pre><code>final int startX = 0;final int deltaY = 100;ValueAnimator animator = ValueAnimator.onInt(0, 1).setDuration(1000);animator.addUpdateListener(new AnimatorUpdateListener() {    @Override    public void onAnimatorUpdate(ValueAnimator animator) {        float fraction = animator.getAnimatedFraction();        mButton.scrollTo(startX+(int)(deltaX * fraction), 0);    }});animator.start();</code></pre><p>在上述代码中，动画的本质并没有作用在任何对象上，他只是在1000ms内完成了一个对象，真正起到滑动效果的是动画监听器的onAnimatorUpdate方法的scrollTo。利用这个特性，我们可以在动画的每一帧到来时获取动画完成比例，然后根据这个比例计算出当前View的滑动距离。</p><h4 id="3-使用延时策略"><a href="#3-使用延时策略" class="headerlink" title="3.使用延时策略"></a>3.使用延时策略</h4><blockquote><p>核心思想：通过发送一系列的延时信息从而达到一种渐进式的效果。使用Handler或View的postDelayed方法，也可以使用线程的sleep方法。</p></blockquote><ul><li>postDelayed：通过它在handleMessage内发送延时信息，然后在消息中进行View的滑动，如果接连不断的发送这种延时信息就可以完成弹性滑动的效果了。</li><li>sleep：通过while循环不断的滑动View和sleep，就可以实现弹性滑动效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 要点提炼——开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity生命周期</title>
      <link href="/2019/03/07/activity-sheng-ming-zhou-qi/"/>
      <url>/2019/03/07/activity-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-返回栈"><a href="#1-返回栈" class="headerlink" title="1.返回栈"></a>1.返回栈</h2><p>Android时使用任务（task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈。<br>栈是一种后进先出的数据结构。在默认情况下，每当我们启用一个新的活动时，这个活动就会放在返回栈的最顶层，当调用Back或finish（）时，返回栈的最顶层的活动就会出栈。<br><img src="http://upload-images.jianshu.io/upload_images/11542292-794b43f5902753c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-活动的状态"><a href="#2-活动的状态" class="headerlink" title="2.活动的状态"></a>2.活动的状态</h2><h3 id="每个活动在其生命周期里有4种状态。"><a href="#每个活动在其生命周期里有4种状态。" class="headerlink" title="每个活动在其生命周期里有4种状态。"></a>每个活动在其生命周期里有4种状态。</h3><ol><li>运行状态：当一个活动位于返回栈的栈顶时，这个活动就会处于运行状态。</li><li>暂停状态：当一个活动不在处于栈顶的位置，但仍然可见时，这个活动就进入了暂停状态。比如：后台、点击一个活动弹出弹框。</li><li>停止状态：当一个活动不在处于栈顶的位置，并且完全不可见时，就进入了停止状态。<br>4.销毁状态：当一个活动从返回栈移除后就变成了销毁状态</li></ol><h2 id="3-活动的生命周期"><a href="#3-活动的生命周期" class="headerlink" title="3.活动的生命周期"></a>3.活动的生命周期</h2><h3 id="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"><a href="#Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。" class="headerlink" title="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"></a>Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。</h3><h5 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h5><p>它在活动第一次被创建时调用，表示活动正在被创建，应该在这个方法中完成活动的初始化的操作。比如：setContentVie()加载布局、初始化Activity数据、绑定事件。</p><h5 id="2-onStart（）"><a href="#2-onStart（）" class="headerlink" title="2.onStart（）"></a>2.onStart（）</h5><p>这个方法在活动由不可见变为可见时调用，表示活动正在被启动，即将开始，其实这个时候我们通常都认为活动已经可见了，但是含没有在前台出现，所以我们看不见。</p><h5 id="3-onResume（）"><a href="#3-onResume（）" class="headerlink" title="3.onResume（）"></a>3.onResume（）</h5><p>这个方法在活动准备和用户进行交互时调用，表示Activity已经可以看见了 ，即：出现在前台，并开始活动了。</p><h5 id="4-onPause"><a href="#4-onPause" class="headerlink" title="4.onPause()"></a>4.onPause()</h5><p>这个方法在系统准备去启动或者恢复另一个活动的时候调用，表示活动正在停止过程中。这个方法紧接着就是onStop()方法，但是特殊情况下，如果这个时候我们快速的回到当前的Activity，那么onResume就会被调用，这种情况属于极端情况，一般情况下很难出现。这个时候可以做一些<strong>数据存储</strong>、<strong>停止动画等工作</strong>，但是不能太耗时，太耗时会影响Activity的显示。</p><h5 id="5-onStop"><a href="#5-onStop" class="headerlink" title="5.onStop"></a>5.onStop</h5><p>这个方法在活动完全不可见时调用。表示Activity即将停止。这个时候我们可以做些稍微重量级的工作，但是又不能太耗时。</p><h5 id="6-onRestart（）"><a href="#6-onRestart（）" class="headerlink" title="6.onRestart（）"></a>6.onRestart（）</h5><p>这个方法在活动由停止状态变成运行状态时调用，表示活动正在重新被启动。</p><h5 id="7-onDestroy"><a href="#7-onDestroy" class="headerlink" title="7.onDestroy()"></a>7.onDestroy()</h5><p>这个方法在活动被销毁之前调用，表示Activity即将被销毁，之后活动就将变成销毁状态。这是Activity生命周期中最后一个回调方法，在这里我们可以做一些<strong>回收工作</strong>和<strong>最终的资源释放</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/11542292-f156f9863d8994ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："><a href="#针对上图这里附加几个常见情况的Activity的生命周期的回调流程：" class="headerlink" title="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："></a>针对上图这里附加几个常见情况的Activity的生命周期的回调流程：</h5><ol><li>针对一个特定的Activity的第一次启动：回调流程：onCreate -&gt; onStart -&gt; onResume</li><li>当用户打开新的Activity或者切换到桌面的时候，.回调流程：onPause -&gt; onStop</li><li>当从Activity(A)跳转到Activity(B)时，回调流程：onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)</li><li>当用户回到原来的Activity时：回调流程：onRestart -&gt; onStart -&gt; onResume</li><li>当用户按back键回退时，回调流程：onPause -&gt; onStop -&gt; onDestory</li></ol><h2 id="4-活动的生存期"><a href="#4-活动的生存期" class="headerlink" title="4.活动的生存期"></a>4.活动的生存期</h2><p>1.完整生存期：活动的创建和销毁：onCreate（）和 onDestroy（）<br>2.可见生存期：活动是否可见：onStart（） 和 onStop（）<br>3.前台生存期：活动是否在前台：onResume（） 和 onPause（）</p><p><img src="media/15519727864455/15519766712395.jpg" alt></p><blockquote><p>问题1:onStart()、onStop() 与 onResume()、onPause()的区别。</p></blockquote><p>这两对生命回调方法看起来差不多，在使用时我们甚至可以只保留一对。他们唯一的不同就是：<br>onStart()、onStop()是从<strong>是否可见</strong>这个角度回调的；onResume()、onPause()是从<strong>是否位于前台</strong>这个角度回调的。</p><blockquote><p>问题2: 假设从ActivityA跳到ActivityB中去，那么ActivityB的onResume回调和ActivityA的onPause回调那个会先执行。</p></blockquote><p>这个问题我们要从Activity的启动流程的源码开始解释了。Activity启动过程的源码非常复杂，主要涉及了<strong>Instrumentation</strong>、<strong>ActivityThread</strong>(Android的主线程)和<strong>ActivityManagerService</strong>(AMS)。简单理解就是：启动一个Activity的请求会由Instrumentation来处理，然后将它通过Binder向AMS发送请求，AMS内部维护着一个ActivityStack(活动栈),并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期的调用。<br>源码这里我就不粘贴出来了，直接上流程吧：</p><ol><li>首先我们看到的是ActivityStack中的resumeTopActivityInnerLocked方法将栈顶的Activity先onPause,然后新Activity才能准备启动</li><li>ActivityStackSupervisor中的realStartActivityLocked()方法中调用app.thread.scheduleLaunchActivity方法，因为app.thread是主线程ActivityThread中的ApplicationThrea的一个实现，所以这个方法实在ActivityThread(主线程)中实现的。</li><li>scheduleLaunchActivity方法会在ActivityThread中调用handleLaunchActivity方法执行onCreate、onStart、onResume回调。</li><li>在handleLaunchActivity方法中会先执行performLaunchActivity方法创建一个Activity，同时调用onCreate和onStart。然后handleResumeActivity方法会执行新建的Activity的onResume回调。</li></ol><h2 id="5-onSaveInstanceState和onRestoreInstanceState"><a href="#5-onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="5.onSaveInstanceState和onRestoreInstanceState"></a>5.onSaveInstanceState和onRestoreInstanceState</h2><p>a.出现时机：Activity异常终止时<br>b.系统异常终止时，调用onSavaInstanceState来保存状态。该方法在onStop之前调用，但和onPause没有时序关系。<br>c.Activity被重新创建时，调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。</p><blockquote><p>onSaveInstanceState与onPause的区别：前者适用于对临时性状态的保存，而后者适用于对数据的持久化保存。</p></blockquote><blockquote><p>可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。<strong>谷歌推荐使用onRestoreInstanceState进行数据恢复</strong>。</p></blockquote><h2 id="6-异常情况下的生命周期分析"><a href="#6-异常情况下的生命周期分析" class="headerlink" title="6. 异常情况下的生命周期分析"></a>6. 异常情况下的生命周期分析</h2><h3 id="1）-资源相关系统配置发生改变导致Activity被杀死重新创建"><a href="#1）-资源相关系统配置发生改变导致Activity被杀死重新创建" class="headerlink" title="1）.资源相关系统配置发生改变导致Activity被杀死重新创建"></a>1）.资源相关系统配置发生改变导致Activity被杀死重新创建</h3><p><img src="media/15519727864455/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"><br>当系统配置发生改变之后，Activity会被销毁，其onPause、onStop、onDestory都会被调用，同时由于Activity是在异常情况下终止的，系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态(onSaveInstanceState调用实在onStop之前的，他和onPause没有固定的顺序关系，既可能在他前面也可能会在他后面)。当Activity被重新创建后，系统会调用<strong>onRestoreInstanceState</strong>方法，并把Activity销毁时<strong>onSaveInstanceState</strong>方法保存的<strong>Bundle对象</strong>作为<strong>参数</strong>同时传给<strong>onRestoreInstanceState方法和onCreate方法</strong>。但要注意onRestoreInstanceState在onStart之后调用。</p><blockquote><p>为了避免由于配置的改变导致Activity重建。可以在AndroidManifest.xml中对应的Activity中设置<code>android:configChanges</code>,然后重写onConfigurationChanged方法。 例如：<br><code>android:configChanges=&quot;orientation|screenSize&quot;</code>,这样在屏幕旋转时Activity就不会被杀死重建了，只会调用onConfigurationChanged方法。</p></blockquote><h3 id="2）-资源内存不足导致优先级较低的Activity被杀死"><a href="#2）-资源内存不足导致优先级较低的Activity被杀死" class="headerlink" title="2）.资源内存不足导致优先级较低的Activity被杀死"></a>2）.资源内存不足导致优先级较低的Activity被杀死</h3><h4 id="Activity的优先级由高到低可以分为如下："><a href="#Activity的优先级由高到低可以分为如下：" class="headerlink" title="Activity的优先级由高到低可以分为如下："></a>Activity的优先级由高到低可以分为如下：</h4><ol><li>前台Activity——正在和用户交互的Activity，优先级最高。</li><li>可见但非前台Activity—比如弹出一个弹窗，导致Activity仍可见但是无法和用户交互。</li><li>后台Activity-已经被暂停的Activity，比如执行了onStop，优先级最低</li></ol><p><strong>当系统内存不足时就会按照上面的优先级从低到高杀掉Activity所在的进程</strong><br><strong>若一个进程没有任意一个四大组件进行，进程也会被很快杀掉</strong></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 要点提炼——开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/07/hello-world/"/>
      <url>/2019/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
