<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>要点提炼-View的事件体系</title>
      <link href="/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/"/>
      <url>/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/</url>
      
        <content type="html"><![CDATA[<p><strong>View是Android中的所有控件的基类，所有的控件都是直接或间接继承自View，所以View在Android中是一个很重要的概念。本篇将简要介绍View。<br>内容如下：</strong></p><ul><li>Android UI界面架构</li><li>View的基础知识</li><li>View的滑动</li><li>弹性滑动</li><li>View的事件分发机制</li><li>View的滑动冲突</li></ul><hr><h3 id="一、Android-UI界面架构"><a href="#一、Android-UI界面架构" class="headerlink" title="一、Android UI界面架构"></a>一、Android UI界面架构</h3><p>讲View之前先涉及一点Android的UI结构，后面的View分发机制会涉及一点这里的知识。<br>每个Activity包含一个<code>PhoneWindow</code>对象，<code>PhoneWindow</code>设置<code>DecorView</code>为应用的根视图（顶级视图）。在里面就是我们熟悉的<code>TitleView</code>和<code>ContentView</code>。<code>titleView</code>的位置就是我们那平常看到的App的标题栏，而我们平时在Activit中使用的<code>setContentView（）</code>就是设置<code>ContentView</code>。<br><img src="media/15523080158777/15523192245211.jpg" alt></p><h3 id="二、View的基础知识"><a href="#二、View的基础知识" class="headerlink" title="二、View的基础知识"></a>二、View的基础知识</h3><h4 id="1、什么是View"><a href="#1、什么是View" class="headerlink" title="1、什么是View"></a>1、什么是View</h4><p><strong>View：</strong>它是一种界面层的控价的一种抽象，它代表了一个控价。Android中的所有的控件都继承自它。<br><strong>ViewGroup：</strong>顾名思义这是一个View的组合，它内部包含了多个View。ViewGroup也继承了View，这就意味着View本身就可以是单个控件也可以是多个控价组成的一组控件。<br>从某种角度讲，Android中的控价可以分为两大类：View和ViewGroup。通过ViewGroup，整个界面可以组成一个View树，上层的View要负责下层View的测量与绘制，并传递事件。<br><img src="media/15523080158777/15523186944755.jpg" alt></p><h4 id="2、View的位置参数"><a href="#2、View的位置参数" class="headerlink" title="2、View的位置参数"></a>2、View的位置参数</h4><p>a. Android坐标系：以屏幕左上角为坐标原点，<strong>向右</strong>为x轴正方向，<strong>向下</strong>为y轴正方向。<br>b. View的位置主要由它的四个顶点决定：top、left、right、bottom</p><ul><li>top：左上角的纵坐标</li><li>left：左上角的横坐标</li><li>right：右下角的横坐标</li><li>bottom：右下角的纵坐标<br><strong>这些都是相对于View的父容器而言的，是一种相对坐标</strong><br><img src="media/15523080158777/15523196534939.jpg" alt><br>由上图就很容易的得到View的宽高和坐标的关系：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width = right - left</span><br><span class="line">height = bottom - top</span><br></pre></td></tr></table></figure></li></ul><p>我们了解了上述View属性，那我们怎么获取这些属性呢。别着急，其实View还提供了get方法帮助我们获取上述属性。</p><ul><li>left = getLeft()</li><li>Right = getRight()</li><li>top = getTop()</li><li>bottom = getBottom</li><li>width = getWidth</li><li>height = getHeight</li></ul><p>c.从Android3.0开始，View增加了额外的几个参数：x、y、translationX、translationY。<br>其中x和y是View左上角的坐标，translationX和translationY是View的左上角相对于父容器的偏移量，他们的默认值均为0。和View的基本属性一样，这些参数也是相对于View父容器的，而且View也提供了set/get方法。</p><p><img src="media/15523080158777/15523201252652.jpg" alt></p><blockquote><p>x = left + translationX<br>y = top + translationY</p></blockquote><p><strong>注意：</strong> View在移动的过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x、y、translationX和translationUY这四个参数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Activity生命周期</title>
      <link href="/2019/03/07/activity-sheng-ming-zhou-qi/"/>
      <url>/2019/03/07/activity-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-返回栈"><a href="#1-返回栈" class="headerlink" title="1.返回栈"></a>1.返回栈</h2><p>Android时使用任务（task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈。<br>栈是一种后进先出的数据结构。在默认情况下，每当我们启用一个新的活动时，这个活动就会放在返回栈的最顶层，当调用Back或finish（）时，返回栈的最顶层的活动就会出栈。<br><img src="http://upload-images.jianshu.io/upload_images/11542292-794b43f5902753c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-活动的状态"><a href="#2-活动的状态" class="headerlink" title="2.活动的状态"></a>2.活动的状态</h2><h3 id="每个活动在其生命周期里有4种状态。"><a href="#每个活动在其生命周期里有4种状态。" class="headerlink" title="每个活动在其生命周期里有4种状态。"></a>每个活动在其生命周期里有4种状态。</h3><ol><li>运行状态：当一个活动位于返回栈的栈顶时，这个活动就会处于运行状态。</li><li>暂停状态：当一个活动不在处于栈顶的位置，但仍然可见时，这个活动就进入了暂停状态。比如：后台、点击一个活动弹出弹框。</li><li>停止状态：当一个活动不在处于栈顶的位置，并且完全不可见时，就进入了停止状态。<br>4.销毁状态：当一个活动从返回栈移除后就变成了销毁状态</li></ol><h2 id="3-活动的生命周期"><a href="#3-活动的生命周期" class="headerlink" title="3.活动的生命周期"></a>3.活动的生命周期</h2><h3 id="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"><a href="#Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。" class="headerlink" title="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"></a>Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。</h3><h5 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h5><p>它在活动第一次被创建时调用，表示活动正在被创建，应该在这个方法中完成活动的初始化的操作。比如：setContentVie()加载布局、初始化Activity数据、绑定事件。</p><h5 id="2-onStart（）"><a href="#2-onStart（）" class="headerlink" title="2.onStart（）"></a>2.onStart（）</h5><p>这个方法在活动由不可见变为可见时调用，表示活动正在被启动，即将开始，其实这个时候我们通常都认为活动已经可见了，但是含没有在前台出现，所以我们看不见。</p><h5 id="3-onResume（）"><a href="#3-onResume（）" class="headerlink" title="3.onResume（）"></a>3.onResume（）</h5><p>这个方法在活动准备和用户进行交互时调用，表示Activity已经可以看见了 ，即：出现在前台，并开始活动了。</p><h5 id="4-onPause"><a href="#4-onPause" class="headerlink" title="4.onPause()"></a>4.onPause()</h5><p>这个方法在系统准备去启动或者恢复另一个活动的时候调用，表示活动正在停止过程中。这个方法紧接着就是onStop()方法，但是特殊情况下，如果这个时候我们快速的回到当前的Activity，那么onResume就会被调用，这种情况属于极端情况，一般情况下很难出现。这个时候可以做一些<strong>数据存储</strong>、<strong>停止动画等工作</strong>，但是不能太耗时，太耗时会影响Activity的显示。</p><h5 id="5-onStop"><a href="#5-onStop" class="headerlink" title="5.onStop"></a>5.onStop</h5><p>这个方法在活动完全不可见时调用。表示Activity即将停止。这个时候我们可以做些稍微重量级的工作，但是又不能太耗时。</p><h5 id="6-onRestart（）"><a href="#6-onRestart（）" class="headerlink" title="6.onRestart（）"></a>6.onRestart（）</h5><p>这个方法在活动由停止状态变成运行状态时调用，表示活动正在重新被启动。</p><h5 id="7-onDestroy"><a href="#7-onDestroy" class="headerlink" title="7.onDestroy()"></a>7.onDestroy()</h5><p>这个方法在活动被销毁之前调用，表示Activity即将被销毁，之后活动就将变成销毁状态。这是Activity生命周期中最后一个回调方法，在这里我们可以做一些<strong>回收工作</strong>和<strong>最终的资源释放</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/11542292-f156f9863d8994ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："><a href="#针对上图这里附加几个常见情况的Activity的生命周期的回调流程：" class="headerlink" title="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："></a>针对上图这里附加几个常见情况的Activity的生命周期的回调流程：</h5><ol><li>针对一个特定的Activity的第一次启动：回调流程：onCreate -&gt; onStart -&gt; onResume</li><li>当用户打开新的Activity或者切换到桌面的时候，.回调流程：onPause -&gt; onStop</li><li>当从Activity(A)跳转到Activity(B)时，回调流程：onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)</li><li>当用户回到原来的Activity时：回调流程：onRestart -&gt; onStart -&gt; onResume</li><li>当用户按back键回退时，回调流程：onPause -&gt; onStop -&gt; onDestory</li></ol><h2 id="4-活动的生存期"><a href="#4-活动的生存期" class="headerlink" title="4.活动的生存期"></a>4.活动的生存期</h2><p>1.完整生存期：活动的创建和销毁：onCreate（）和 onDestroy（）<br>2.可见生存期：活动是否可见：onStart（） 和 onStop（）<br>3.前台生存期：活动是否在前台：onResume（） 和 onPause（）</p><p><img src="media/15519727864455/15519766712395.jpg" alt></p><blockquote><p>问题1:onStart()、onStop() 与 onResume()、onPause()的区别。</p></blockquote><p>这两对生命回调方法看起来差不多，在使用时我们甚至可以只保留一对。他们唯一的不同就是：<br>onStart()、onStop()是从<strong>是否可见</strong>这个角度回调的；onResume()、onPause()是从<strong>是否位于前台</strong>这个角度回调的。</p><blockquote><p>问题2: 假设从ActivityA跳到ActivityB中去，那么ActivityB的onResume回调和ActivityA的onPause回调那个会先执行。</p></blockquote><p>这个问题我们要从Activity的启动流程的源码开始解释了。Activity启动过程的源码非常复杂，主要涉及了<strong>Instrumentation</strong>、<strong>ActivityThread</strong>(Android的主线程)和<strong>ActivityManagerService</strong>(AMS)。简单理解就是：启动一个Activity的请求会由Instrumentation来处理，然后将它通过Binder向AMS发送请求，AMS内部维护着一个ActivityStack(活动栈),并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期的调用。<br>源码这里我就不粘贴出来了，直接上流程吧：</p><ol><li>首先我们看到的是ActivityStack中的resumeTopActivityInnerLocked方法将栈顶的Activity先onPause,然后新Activity才能准备启动</li><li>ActivityStackSupervisor中的realStartActivityLocked()方法中调用app.thread.scheduleLaunchActivity方法，因为app.thread是主线程ActivityThread中的ApplicationThrea的一个实现，所以这个方法实在ActivityThread(主线程)中实现的。</li><li>scheduleLaunchActivity方法会在ActivityThread中调用handleLaunchActivity方法执行onCreate、onStart、onResume回调。</li><li>在handleLaunchActivity方法中会先执行performLaunchActivity方法创建一个Activity，同时调用onCreate和onStart。然后handleResumeActivity方法会执行新建的Activity的onResume回调。</li></ol><h2 id="5-onSaveInstanceState和onRestoreInstanceState"><a href="#5-onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="5.onSaveInstanceState和onRestoreInstanceState"></a>5.onSaveInstanceState和onRestoreInstanceState</h2><p>a.出现时机：Activity异常终止时<br>b.系统异常终止时，调用onSavaInstanceState来保存状态。该方法在onStop之前调用，但和onPause没有时序关系。<br>c.Activity被重新创建时，调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。</p><blockquote><p>onSaveInstanceState与onPause的区别：前者适用于对临时性状态的保存，而后者适用于对数据的持久化保存。</p></blockquote><blockquote><p>可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。<strong>谷歌推荐使用onRestoreInstanceState进行数据恢复</strong>。</p></blockquote><h2 id="6-异常情况下的生命周期分析"><a href="#6-异常情况下的生命周期分析" class="headerlink" title="6. 异常情况下的生命周期分析"></a>6. 异常情况下的生命周期分析</h2><h3 id="1）-资源相关系统配置发生改变导致Activity被杀死重新创建"><a href="#1）-资源相关系统配置发生改变导致Activity被杀死重新创建" class="headerlink" title="1）.资源相关系统配置发生改变导致Activity被杀死重新创建"></a>1）.资源相关系统配置发生改变导致Activity被杀死重新创建</h3><p><img src="media/15519727864455/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"><br>当系统配置发生改变之后，Activity会被销毁，其onPause、onStop、onDestory都会被调用，同时由于Activity是在异常情况下终止的，系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态(onSaveInstanceState调用实在onStop之前的，他和onPause没有固定的顺序关系，既可能在他前面也可能会在他后面)。当Activity被重新创建后，系统会调用<strong>onRestoreInstanceState</strong>方法，并把Activity销毁时<strong>onSaveInstanceState</strong>方法保存的<strong>Bundle对象</strong>作为<strong>参数</strong>同时传给<strong>onRestoreInstanceState方法和onCreate方法</strong>。但要注意onRestoreInstanceState在onStart之后调用。</p><blockquote><p>为了避免由于配置的改变导致Activity重建。可以在AndroidManifest.xml中对应的Activity中设置<code>android:configChanges</code>,然后重写onConfigurationChanged方法。 例如：<br><code>android:configChanges=&quot;orientation|screenSize&quot;</code>,这样在屏幕旋转时Activity就不会被杀死重建了，只会调用onConfigurationChanged方法。</p></blockquote><h3 id="2）-资源内存不足导致优先级较低的Activity被杀死"><a href="#2）-资源内存不足导致优先级较低的Activity被杀死" class="headerlink" title="2）.资源内存不足导致优先级较低的Activity被杀死"></a>2）.资源内存不足导致优先级较低的Activity被杀死</h3><h4 id="Activity的优先级由高到低可以分为如下："><a href="#Activity的优先级由高到低可以分为如下：" class="headerlink" title="Activity的优先级由高到低可以分为如下："></a>Activity的优先级由高到低可以分为如下：</h4><ol><li>前台Activity——正在和用户交互的Activity，优先级最高。</li><li>可见但非前台Activity—比如弹出一个弹窗，导致Activity仍可见但是无法和用户交互。</li><li>后台Activity-已经被暂停的Activity，比如执行了onStop，优先级最低</li></ol><p><strong>当系统内存不足时就会按照上面的优先级从低到高杀掉Activity所在的进程</strong><br><strong>若一个进程没有任意一个四大组件进行，进程也会被很快杀掉</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/07/hello-world/"/>
      <url>/2019/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
