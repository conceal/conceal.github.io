<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>要点提炼-View的事件体系</title>
      <link href="/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/"/>
      <url>/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/</url>
      
        <content type="html"><![CDATA[<p><strong>View是Android中的所有控件的基类，所有的控件都是直接或间接继承自View，所以View在Android中是一个很重要的概念。本篇将简要介绍View。<br>内容如下：</strong></p><ul><li>Android UI界面架构</li><li>View的基础知识</li><li>View的滑动</li><li>弹性滑动</li><li>View的事件分发机制</li><li>View的滑动冲突</li></ul><hr><h3 id="一、Android-UI界面架构"><a href="#一、Android-UI界面架构" class="headerlink" title="一、Android UI界面架构"></a>一、Android UI界面架构</h3><p>讲View之前先涉及一点Android的UI结构，后面的View分发机制会涉及一点这里的知识。<br>每个Activity包含一个<code>PhoneWindow</code>对象，<code>PhoneWindow</code>设置<code>DecorView</code>为应用的根视图（顶级视图）。在里面就是我们熟悉的<code>TitleView</code>和<code>ContentView</code>。<code>titleView</code>的位置就是我们那平常看到的App的标题栏，而我们平时在Activit中使用的<code>setContentView（）</code>就是设置<code>ContentView</code>。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrn2iri7j30ve0g0k2g.jpg" alt></p><h3 id="二、View的基础知识"><a href="#二、View的基础知识" class="headerlink" title="二、View的基础知识"></a>二、View的基础知识</h3><h4 id="1、什么是View"><a href="#1、什么是View" class="headerlink" title="1、什么是View"></a>1、什么是View</h4><p><strong>View：</strong>它是一种界面层的控价的一种抽象，它代表了一个控价。Android中的所有的控件都继承自它。<br><strong>ViewGroup：</strong>顾名思义这是一个View的组合，它内部包含了多个View。ViewGroup也继承了View，这就意味着View本身就可以是单个控件也可以是多个控价组成的一组控件。<br>从某种角度讲，Android中的控价可以分为两大类：View和ViewGroup。通过ViewGroup，整个界面可以组成一个View树，上层的View要负责下层View的测量与绘制，并传递事件。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrnrvi8aj30j60b3dj1.jpg" alt></p><h4 id="2、View的位置参数"><a href="#2、View的位置参数" class="headerlink" title="2、View的位置参数"></a>2、View的位置参数</h4><p>a. Android坐标系：以屏幕左上角为坐标原点，<strong>向右</strong>为x轴正方向，<strong>向下</strong>为y轴正方向。<br>b. View的位置主要由它的四个顶点决定：top、left、right、bottom</p><ul><li>top：左上角的纵坐标</li><li>left：左上角的横坐标</li><li>right：右下角的横坐标</li><li>bottom：右下角的纵坐标<br><strong>这些都是相对于View的父容器而言的，是一种相对坐标</strong><br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zro3hdndj30c50bkq42.jpg" alt><br>由上图就很容易的得到View的宽高和坐标的关系：<pre><code>width = right - leftheight = bottom - top</code></pre>我们了解了上述View属性，那我们怎么获取这些属性呢。别着急，其实View还提供了get方法帮助我们获取上述属性。</li><li>left = getLeft()</li><li>Right = getRight()</li><li>top = getTop()</li><li>bottom = getBottom</li><li>width = getWidth</li><li>height = getHeight</li></ul><p>c.从Android3.0开始，View增加了额外的几个参数：x、y、translationX、translationY。<br>其中x和y是View左上角的坐标，translationX和translationY是View的左上角相对于父容器的偏移量，他们的默认值均为0。和View的基本属性一样，这些参数也是相对于View父容器的，而且View也提供了set/get方法。</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zroc04s9j30kl0hd788.jpg" alt></p><blockquote><p>x = left + translationX<br>y = top + translationY</p></blockquote><p><strong>注意：</strong> View在移动的过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x、y、translationX和translationUY这四个参数。另外在onCreate()方法里面无法获取到View的坐标参数，这是因为此时的View还未开始绘制，全部的坐标参数都将是0。</p><h4 id="3-MotionEvent和TouchSlop"><a href="#3-MotionEvent和TouchSlop" class="headerlink" title="3. MotionEvent和TouchSlop"></a>3. MotionEvent和TouchSlop</h4><h5 id="1-MotionEvent"><a href="#1-MotionEvent" class="headerlink" title="1.MotionEvent"></a>1.MotionEvent</h5><p>在手指接触屏幕后所产生的一系列的事件，典型的事件类型有：</p><ul><li>ACTION_DOWN -—— 手指接触屏幕</li><li>ACTION_MOVE -—— 手指在屏幕上移动</li><li>ACTION_UP ———— 手指从屏幕上松开的一瞬间<br>正常情况下，一次手指接触屏幕的行为就会触发一系列的事件，列出两种典型情况：</li><li>点击屏幕后松开：ACTION_DOWN -&gt; ACTION_UP</li><li>点击屏幕后滑动一段距离松开：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_UP</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5494434-1fe5babc389caa90?imageMogr2/auto-orient/" alt></p><p><strong>在Android中所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、历史记录、第几个手指等，所以我们可以通过MotionEvent对象来得到点击事件的x和y坐标。为此系统提供了两组方法：getX/getY和getRawX/getRawY。</strong></p><ul><li>getX/getY: 返回相当于当前View左上角的坐标</li><li>getRawX/getRawY: 放回对于手机屏幕左上角的坐标 </li></ul><p>具体关系如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5494434-825bc5992190e5e8?imageMogr2/auto-orient/" alt></p><h5 id="2-TouchSlop"><a href="#2-TouchSlop" class="headerlink" title="2. TouchSlop"></a>2. TouchSlop</h5><p>TouchSlops是系统所能识别出来的滑动的最小的距离。即这是一个常量，当手机在屏幕上的滑动距离小于这个常量的时候，系统就不会认为这是一个滑动操作。这个常量和设备有关，在不同的设备上有不同的值，我们可以通过<code>ViewConfiguration.get(get(context)).getScaledTouchSlop()</code>获取到这个常量。</p><h4 id="4-VelocityTracker、GestureDetector和Scroller"><a href="#4-VelocityTracker、GestureDetector和Scroller" class="headerlink" title="4. VelocityTracker、GestureDetector和Scroller"></a>4. VelocityTracker、GestureDetector和Scroller</h4><h5 id="1-VelocityTracker"><a href="#1-VelocityTracker" class="headerlink" title="1. VelocityTracker"></a>1. VelocityTracker</h5><p>–速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。<br>使用过程：首先在View的<code>onTouchEvent</code>方法中追踪当前事件的速度：</p><pre><code>VelocityTracker mVelocityTracker = VelocityTracker.obtain();mVelocityTracker.addMovement(event);</code></pre><p>接着，在<strong>ACTION_MOVe</strong>事件中获取当前的速度：</p><pre><code>mVolocityTracker.computeCurrenVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity();float yXelocity = mVelocityTracker.getYVelocity();</code></pre><p>最后，当不需要使用它是，需要调用clear方法来重置并回收内存：</p><pre><code>mVelocityTracker.clear();mVelocityTracker.recycle();</code></pre><p><strong>注意这里计算的速度值为1000ms时间间隔移动的像素值，假设移动了100像素，速度就是100像素/秒</strong></p><h5 id="2-GestureDetector"><a href="#2-GestureDetector" class="headerlink" title="2. GestureDetector"></a>2. GestureDetector</h5><p>–手势检测。用于辅助检测用户的点击、滑动、长按、双击等行为。<br>使用过程：<br>创建一个<code>GestureDetector</code>对象并实现<code>onGestureLister</code>接口，根据需要是想点击方法：</p><pre><code>GestureDetector mGestureDetector = new GestureDetector(this);mGestureDetector.setIsLongpressEnabled(false);  //解决长按屏幕后无法实现拖动的现象</code></pre><p>接着，接管目标<code>View</code>的<code>onTouchEvent</code>方法，在待监听View的<code>onTouchEvent</code>方法中添加如下实现：</p><pre><code>boolean consume = mGestureDetector.onTouchEvent(event);return consume;</code></pre><p>做完上面两步我们就可以有选择的实现OnGestureListener和OnDoubleTapListener中的方法了,OnGestureListener和OnDoubleTapListener接口中的方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>所属接口</th></tr></thead><tbody><tr><td>onDown</td><td>手指轻轻接触屏幕的一瞬间，只有一个ACTION_DOWN</td><td>OnGestureListener</td></tr><tr><td>onShowPress</td><td>手指轻轻触摸屏幕，尚未松开或拖动， 由1个ACTION_DOWN触发</td><td>OnGestureListener</td></tr><tr><td>onSingleTopUp</td><td>手指（轻轻触摸屏幕后）松开，伴随着一个ACTION_UP触发（这是点击行为）</td><td>OnGestureListener</td></tr><tr><td>onScroll</td><td>手指按下屏幕并拖动，由1个ACTION_DOWN和多个ACTION_MOVE触发（这是拖动功能）</td><td>OnGestureListener</td></tr><tr><td>onLongPress</td><td>用户长按屏幕</td><td>OnGestureListener</td></tr><tr><td>onFling</td><td>用户触摸屏幕、快速的滑动后松开，由1个ACTION_DOWN、多个ACTION_MOVE和1个ACTION_UP触发，这是快速滑动行为</td><td>OnGestureListener</td></tr><tr><td>onDoubleTap</td><td>双击，由2个ACTION_DOWN触发，他不能和onSingleTapConfirmed共存</td><td>onDoubleTapListener</td></tr><tr><td>onSingleTapConfirmed</td><td>严格的点击行为</td><td>onDoubleTapListener</td></tr><tr><td>onDoubleTapEvent</td><td>表示发生了双击行为，在双击的期间，ACTION_DOWN、ACTION_MOVE、ACTION_UP都会触发次回调</td><td>onDoubleTapListener</td></tr></tbody></table><blockquote><p>在实际开发中可以不使用GestureDetector，完全可以自己在onTouchEvent中实现所需的监听。另外，如果知识监听滑动相关的，建议自己在onGestureDetector中实现，如果要监听双击这种行为的话，就使用GestureDetecter。</p></blockquote><h5 id="3-Scroller"><a href="#3-Scroller" class="headerlink" title="3. Scroller"></a>3. Scroller</h5><p>弹性滑动，用于实现View的弹性滑动。<br>当时使用scrollTo/scrollBy滑动时，滑动是瞬间完成的，这样的滑动效果看起来没有流畅感。这个时候就需要使用Scroller来实现由过渡效果的滑动。Scroller的话送不是瞬间完成的，它是在一定时间间隔内完成的。Scroller本身不能使View滑动，它需要配合View的computeScroll方法才能共同完成View的滑动。下面是一个简单的实现弹性滑动的代码：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();    int delta = destX - scrollX;    //1000ms内滑向destX，效果就是慢慢滑动    mScroller.startScroll(scrollX, 0, delta, 0, 1000);    invalidate();}@Overridepublic void computeScroll() {    if(mScroller.computeScrollOffSet()) {        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());        postInvalidate();    }}</code></pre><h3 id="三、View的滑动"><a href="#三、View的滑动" class="headerlink" title="三、View的滑动"></a>三、View的滑动</h3><blockquote><p><strong>实现View滑动的三种方式：</strong></p><ol><li>通过View本身提供的scrollTo/scrollBy方法</li><li>通过动画给View施加平移效果</li><li>通过改变View的LayoutParams使得View重新布局</li></ol></blockquote><h4 id="1-使用scrollTo-scrollBy"><a href="#1-使用scrollTo-scrollBy" class="headerlink" title="1. 使用scrollTo/scrollBy"></a>1. 使用scrollTo/scrollBy</h4><p>为了实现View的滑动，Vie提供了专门的方法实现这个功能：scrollTo和scrollBy<br><strong>scrollTo()</strong>:在当前视图内容偏移至(x , y)坐标处，即显示(可视)区域位于(x , y)坐标处。</p><pre><code>/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */    public void scrollTo(int x, int y) {        //偏移位置发生了改变        if (mScrollX != x || mScrollY != y) {              int oldX = mScrollX;            int oldY = mScrollY;            mScrollX = x;  //赋新值，保存当前便宜量            mScrollY = y;            //回调onScrollChanged方法            onScrollChanged(mScrollX, mScrollY, oldX, oldY);            if (!awakenScrollBars()) {                invalidate();  //一般都引起重绘            }        }    }</code></pre><p><strong>scrollBy():</strong>：在当前视图内容继续偏移(x , y)个单位，显示(可视)区域也跟着偏移(x,y)个单位。</p><pre><code> /**       * Move the scrolled position of your view. This will cause a call to       * {@link #onScrollChanged(int, int, int, int)} and the view will be       * invalidated.       * @param x the amount of pixels to scroll by horizontally       * @param y the amount of pixels to scroll by vertically       */      // 看出原因了吧 。。 mScrollX 与 mScrollY 代表我们当前偏移的位置 ， 在当前位置继续偏移(x ,y)个单位      public void scrollBy(int x, int y) {          scrollTo(mScrollX + x, mScrollY + y);      }</code></pre><p><strong>总结:scrollTo()指的是移动到制定的(x,y)位置，而scrollBy(x,y)指的是，在当前位置在移动(x,y)个位置</strong></p><p>mScrollX和mScrollY分别表示View在X、Y方向的滚动距离。mScrollX：View的左边缘减去View的内容的左边缘；mScrollY：View的上边缘减去View的内容的上边缘。从右向左滑动，mScrollX为正值，反之为负值；从下往上滑动，mScrollY为正值，反之为负值。（更直观感受：查看下一张照片或者查看长图时手指滑动方向为正）</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g10db9qbgdj30jg0dracq.jpg" alt></p><h4 id="2-使用动画"><a href="#2-使用动画" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p> 这节我们讲解如何使用动画来移动View，主要操作是View的<code>translationX</code>和<code>translationY</code>的属性,既可以采用传统的View动画，也可以采用属性动画（如果使用属性动画的话，为了能够兼容3.0以下的版本，需要采用开源动画<code>nineoldandroids</code>(<a href="http://nineoldandroids.com/）" target="_blank" rel="noopener">http://nineoldandroids.com/）</a><br> 采用View动画代码，如下所示。此动画可以在100ms内将一个View从原始位置向右下角移动100个像素。</p><pre><code> &lt;?xml veision=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:fillAfter=&quot;true&quot;    android:zAdjustment=&quot;normal&quot;&gt;    &lt;translate         android:duration=&quot;100&quot;        android:fromXDelta=&quot;0&quot;        android:fromYDelta=&quot;0&quot;        android:interpolator=&quot;@android:anim/linear_interpolator&quot;        android:toXDelata=&quot;100&quot;        android:toYDelata=&quot;100&quot;/&gt;&lt;/set&gt;</code></pre><p> 采用属性动画就更简单了：</p><pre><code> ObjectAnimator.ofFloat(targetView, &quot;translationX&quot;, 0, 100).setDuration(100).start();</code></pre><p>View动画是对View的影像的操作，他并不能真正改变View的参数，包括宽/高，并且如果希望动画移动后的状态保留还必须讲<code>fillAfter</code>属性设置为true。而属性动画并不存在上述的问题，但是在Android3.0以下就不能使用属性动画了。</p><h4 id="3-使用LayoutParams将一个View重新布局"><a href="#3-使用LayoutParams将一个View重新布局" class="headerlink" title="3.使用LayoutParams将一个View重新布局"></a>3.使用LayoutParams将一个View重新布局</h4><p>比如将一个View向右移动100像素，向右，只需要把它的marginLeft参数增大即可，代码见下：</p><pre><code>MarginLayoutParams params = (MarginLayoutParams) btn.getLayoutParams();params.leftMargin += 100;btn.requestLayout();// 请求重新对View进行measure、layout//或btn.setLayoutParams(params);</code></pre><h4 id="4、各种滑动方式的比较"><a href="#4、各种滑动方式的比较" class="headerlink" title="4、各种滑动方式的比较"></a>4、各种滑动方式的比较</h4><ul><li>scrollTo/scrollBy：操作简单适合对View内容的滑动</li><li>动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</li><li>LayoutParams：操作稍微复杂，适合于有交互的View</li></ul><h3 id="四、弹性滑动"><a href="#四、弹性滑动" class="headerlink" title="四、弹性滑动"></a>四、弹性滑动</h3><p>上一节讲了View的滑动，但是这种直接滑动效果实在是太差了，这里我们学习如何实现渐进式滑动。虽然实现的方法有很多，但是基本思想都是一样的：将一次滑动分成若干次小的滑动，并在一定时间内完成。这里介绍三种实现方式：Scroller、Handler#postDelayed以及Thread#sleep。</p><h4 id="1-Scroller"><a href="#1-Scroller" class="headerlink" title="1.Scroller"></a>1.Scroller</h4><blockquote><ul><li>与scrollTo/scrollBy不同：scrollTo/scrollBy过程是瞬间完成的，非平滑；而Scroller则有过渡滑动的效果。</li><li>注意：Scoller本身无法让View弹性滑动，它需要和View的computerScroller方法配合使用。</li></ul></blockquote><p>再看一次Scroller的经典使用方法：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();//View的左边缘到其内容左边缘的距离  int scrollY = getScrollY();//View的上边缘到其内容上边缘的距离  int deltaX = dstX - scrollX;//x方向滑动的位移量  int deltaY = dstY - scrollY;//y方向滑动的位移量  scroller.startScroll(scrollX, scrollY, deltaX, deltaY, 1000); //开始滑动  invalidate(); //刷新界面}@Override//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记public void computeScroll() {  if (scroller.computeScrollOffset()) {     scrollTo(scroller.getCurrX(), scroller.getCurY());    postInvalidate();//通过不断的重绘不断的调用computeScroll方法  }}</code></pre><p>工作原理：当我们构造一个Scroller对象并且调用他的startScroll方法时，Scroller内部其实什么也没有做，他只是保存了我们传递的几个参数，这几个参数从startScroll的源码里就能看出：</p><pre><code>public void startScroll(int startX,int startY,int dx,int dy,int duration){  mMode = SCROLL_MODE;  mFinished = false;  mDuration = duration;//滑动时间  mStartTime = AnimationUtils.currentAminationTimeMills();//开始时间  mStartX = startX;//滑动起点  mStartY = startY;//滑动起点  mFinalX = startX + dx;//滑动终点  mFinalY = startY + dy;//滑动终点  mDeltaX = dx;//滑动距离  mDeltaY = dy;//滑动距离  mDurationReciprocal = 1.0f / (float)mDuration; }</code></pre><blockquote><p><strong>具体过程：</strong>在MotionEvent.ACTION_UP事件触发时调用startScroll方法-&gt;马上调用invalidate/postInvalidate方法-&gt;会请求View重绘，导致View.draw方法被执行-&gt;会调用View.computeScroll方法，此方法是空实现，需要自己处理逻辑。具体逻辑是：先判断computeScrollOffset，若为true（表示滚动未结束），则执行scrollTo方法，它会再次调用postInvalidate，如此反复执行，直到返回值为false。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g110wgux3cj30vw0kq43j.jpg" alt></p><blockquote><p>Scroll的computeScrollOffset()根据时间的流逝动态计算一小段时间里View滑动的距离，并得到当前View位置，再通过scrollTo继续滑动。即把一次滑动拆分成无数次小距离滑动从而实现弹性滑动。</p></blockquote><h4 id="2-使用动画-1"><a href="#2-使用动画-1" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p>动画本身就是一种渐进的过程，因此通过动画来实现滑动天然就有一种弹性效果。</p><pre><code>ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start();//在100ms内使得View从原始位置向右平移100像素</code></pre><p>我们还可以利用动画的特性来实现一些动画无法实现的特效，还拿scrollTo来说,我们想模仿Scroller来实现View的弹性滑动。</p><pre><code>final int startX = 0;final int deltaY = 100;ValueAnimator animator = ValueAnimator.onInt(0, 1).setDuration(1000);animator.addUpdateListener(new AnimatorUpdateListener() {    @Override    public void onAnimatorUpdate(ValueAnimator animator) {        float fraction = animator.getAnimatedFraction();        mButton.scrollTo(startX+(int)(deltaX * fraction), 0);    }});animator.start();</code></pre><p>在上述代码中，动画的本质并没有作用在任何对象上，他只是在1000ms内完成了一个对象，真正起到滑动效果的是动画监听器的onAnimatorUpdate方法的scrollTo。利用这个特性，我们可以在动画的每一帧到来时获取动画完成比例，然后根据这个比例计算出当前View的滑动距离。</p><h4 id="3-使用延时策略"><a href="#3-使用延时策略" class="headerlink" title="3.使用延时策略"></a>3.使用延时策略</h4><blockquote><p>核心思想：通过发送一系列的延时信息从而达到一种渐进式的效果。使用Handler或View的postDelayed方法，也可以使用线程的sleep方法。</p></blockquote><ul><li>postDelayed：通过它在handleMessage内发送延时信息，然后在消息中进行View的滑动，如果接连不断的发送这种延时信息就可以完成弹性滑动的效果了。</li><li>sleep：通过while循环不断的滑动View和sleep，就可以实现弹性滑动效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 要点提炼——开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/07/hello-world/"/>
      <url>/2019/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
