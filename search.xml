<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>要点提炼——继承与多态</title>
      <link href="/2019/04/09/yao-dian-ti-lian-ji-cheng-yu-duo-tai/"/>
      <url>/2019/04/09/yao-dian-ti-lian-ji-cheng-yu-duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类的继承"><a href="#一、类的继承" class="headerlink" title="一、类的继承"></a>一、类的继承</h2><p>在面向对象编程中，继承是一个缩短代码以及复用代码的良好的机制。一个继承了父类的子类，包含了父类所有的方法，也可以重载或添加新的内容。</p><h3 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h3><pre><code>[修饰符] class 子类名 extends 父类名 {    //子类体；}</code></pre><h3 id="2-子类对父类成员的可访问特性"><a href="#2-子类对父类成员的可访问特性" class="headerlink" title="2. 子类对父类成员的可访问特性"></a>2. 子类对父类成员的可访问特性</h3><p>子类是对父类的一种延伸，但是子类对父类成员变量的访问性确实由访问特性控制的。<br>如果父类和子类在同一个包中，那么子类可以访问父类的具有public、protected和默认访问特性的成员方法，对于private访问特性的成员方法，需要通过父类提供的操作接口实现。<br>如果父类和子类不再同一个包中，那么子类只能访问父类的具有public和protected访问特性的成员变量，对于默认访问特性以及private的访问特性的成员变量只能通过父类的操作接口实现。<br><img src="https://ws1.sinaimg.cn/large/0077HGE3ly1g1w3r905aqj33402bs4qq.jpg" alt></p><h3 id="3-子类构造方法的定义与执行"><a href="#3-子类构造方法的定义与执行" class="headerlink" title="3.子类构造方法的定义与执行"></a>3.子类构造方法的定义与执行</h3><p>在Java程序中，子类不负责调用父类的构造方法。在创建子类时需要在构造方法中利用super()调用父类的构造方法，注意这条语句要放在构造方法的第一行，如果子类没有调用父类的构造方法，子类会默认调用父类的无参构造方法。另外父类必须要构造无参构造方法，否则会出现编译错误。对于父类中的带参构造方法，子类不会默认调用，必须人工调用。</p><h2 id="二、类的成员方法的重载与覆盖"><a href="#二、类的成员方法的重载与覆盖" class="headerlink" title="二、类的成员方法的重载与覆盖"></a>二、类的成员方法的重载与覆盖</h2><h3 id="1-重载与覆盖"><a href="#1-重载与覆盖" class="headerlink" title="1. 重载与覆盖"></a>1. 重载与覆盖</h3><ol><li><p><strong>成员方法的重载</strong><br>所谓的重载是指在当一个类定义成员方法时，类定义一个与本类或父类的成员方法<strong>同名但参数列表不同</strong>的方法，在调用这个成员方法时，系统会根据参数列表匹配合适的成员方法。</p></li><li><p><strong>成员方法的覆盖</strong><br>在Java中，成员方法的名称和参数列表统称为签名。当子类的成员变量定义一个和父类的成员方法<strong>同名且参数列表也相同</strong>的成员方法时，这个成员方法就覆盖了父类或本类的成员方法了。当调用这个成员方法时，系统就会调用这个新的成员方法。</p></li></ol><h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h3><p>在Java程序中，多态性是值不同的类对象调用同一个签名的成员方法时，将会执行不同的代码段的现象。<br>实现多态的步骤：</p><ol><li>在子类中覆盖父类的成员方法</li><li>定义父类的对象引用，并由它引用创建的父类对象。</li></ol><p>示例代码：</p><pre><code>public class Main {    public static void main(String[] args) {        A class1 = new A();        A class2 = new B();        System.out.println(&quot;class1: a=&quot; + (class1).a);        System.out.println(&quot;class2: a=&quot; + ((B) class2).a);        class1.fun();        class2.fun();    }}class A {    public int a = 0;    public void fun() {        System.out.println(&quot;---A----&quot;);    }}class B extends A {    public int a =1;    public void fun() {        System.out.println(&quot;----B----&quot;);    }}</code></pre><h2 id="三-抽象类"><a href="#三-抽象类" class="headerlink" title="三. 抽象类"></a>三. 抽象类</h2><blockquote><p>抽象类是对一种概念事物的抽象，将其设置为抽象类的原因就是他不是一个具体的事物，Java程序需要限制直接创建这个类的对象。</p></blockquote><ul><li><strong>语法</strong></li></ul><p>在Java语言中，抽象类就是用abstract修饰符定义的类，其格式为：</p><pre><code>[修饰符] abstract class 抽象类名 {    //  成员变量与成员方法}</code></pre><ul><li><strong>注意事项</strong></li></ul><ol><li>任何包含抽象方法的类必须声明为抽象类</li><li>多态性：抽象类不能被实例化，但是可以创建抽象类的应用，然后用它引用子类该抽象类的某个可以实例化的子类的对象</li><li>抽象类必须被子类继承，且子类必须实现父类的抽象方法</li><li>static、private和final修饰符布鞥应用与抽象方法中 </li></ol><h2 id="四-接口"><a href="#四-接口" class="headerlink" title="四. 接口"></a>四. 接口</h2><blockquote><p>在Java中，接口就是一种特殊的抽象类，其特性在于：<strong>接口的内部只允许包含常量和抽象方法</strong>。常量默认为<code>public static final</code>,抽象方法默认我<code>public abstract</code>。<br><strong>使用接口的目的是统一公共常量、规范公共的操作接口的管理，提高了代码的重用。</strong></p></blockquote><ul><li><p>接口定义</p><pre><code>[修饰符] interface 接口名 {  public static final int a = 0;       //常量  public abstract 返回值 方法名();    //抽象方法}</code></pre></li><li><p>实现接口</p><pre><code>[修饰符] class 类名 implements 接口名 {  //实现抽象方法}</code></pre><h2 id="五-包"><a href="#五-包" class="headerlink" title="五. 包"></a>五. 包</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><blockquote><p>在Java语言中，<strong>包</strong>是用于组织类和接口的机制。</p></blockquote></li></ul><p>按照功能将类与接口分装在不同的包中有两点好处：</p><ol><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用，同时便于将若干个已存在的类或接口整体的加载到一个程序中</li><li>避免出现名字冲突的现象(不同包中的文件名可以相同) </li><li>包也限定了访问权限，拥有包访问权限的类才能访问某个包的类</li></ol><ul><li><strong>包的语法格式</strong></li></ul><pre><code>package net.java.util;public class Something{   ...}</code></pre><p>保存路径： <code>net/java/util/Something.java</code></p><h3 id="2-包的创建与导入方式"><a href="#2-包的创建与导入方式" class="headerlink" title="2. 包的创建与导入方式"></a>2. 包的创建与导入方式</h3><p>创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。<br>例子：</p><pre><code>/* 文件名: Animal.java */package animals;interface Animal {   public void eat();   public void travel();}</code></pre><p>接下来在同一个包中加入该接口的实现：</p><pre><code>package animals;/* 文件名 : MammalInt.java */public class MammalInt implements Animal{   public void eat(){      System.out.println(&quot;Mammal eats&quot;);   }   public void travel(){      System.out.println(&quot;Mammal travels&quot;);   }    public int noOfLegs(){      return 0;   }   public static void main(String args[]){      MammalInt m = new MammalInt();      m.eat();      m.travel();   }}</code></pre><h3 id="3-import关键字"><a href="#3-import关键字" class="headerlink" title="3. import关键字"></a>3. import关键字</h3><p>为了能够使用某一个包的成员，Java提供了“import”语句导入使用包的成员。其语法格式为：</p><pre><code>import package1[.package2…].(classname|*);</code></pre><h3 id="4-package的目录结构"><a href="#4-package的目录结构" class="headerlink" title="4. package的目录结构"></a>4. package的目录结构</h3><p>类放在包中会有两种主要的结果：</p><ul><li>包名成为类名的一部分</li><li>包名必须与响应的字节码所在的目录结构相吻合<br>下面就是管理java文件的一种方式：<br>将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类的名字，并以.java作为扩展名。例如：</li></ul><pre><code>// 文件名 :  Car.javapackage vehicle;public class Car {   // 类实现  }</code></pre><p>接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。</p><pre><code>....\vehicle\Car.java</code></pre><p>现在，正确的类名和路径将会是如下样子：<br>类名 -&gt; vehicle.Car<br>路径名 -&gt; vehicle\Car.java (在 windows 系统中)</p><p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名，如：互联网域名为baidu.com，所有的包名都以com.baidu开头。包名中的每一个部分对应一个子目录。</p><ol><li><p>例如:有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：<code>....\com\runoob\test\Runoob.java</code>编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类的名字，并加上 .class 作为扩展后缀。 例如：</p><pre><code>// 文件名: Runoob.javapackage com.runoob.test;public class Runoob { }class Google {     //类体 }</code></pre></li><li><p>现在，用-d来编译这个文件,如下：</p><pre><code>$javac -d . Runoob.java</code></pre></li><li><p>这样就会像下面这样放置编译了的文件：</p><pre><code>.\com\runoob\test\Runoob.class.\com\runoob\test\Google.class</code></pre></li><li><p>然后就可以像下面这样导入所有\com\runoob\test\ 中定义的类、接口等：</p><pre><code>import com.runoob.test.*;</code></pre></li><li><p>编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。</p><pre><code>&lt;path-one&gt;\sources\com\runoob\test\Runoob.java&lt;path-two&gt;\classes\com\runoob\test\Google.class</code></pre></li><li><p>这样，就可以将类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到程序中使用的所有类型。<br>类目录的绝对路径叫做 <code>class path</code>。设置在系统变量 <code>CLASSPATH</code>中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。<br><code>&lt;path- two&gt;\classes</code> 是 <code>class path</code>，<code>package</code> 名字是 <code>com.runoob.test</code>,而编译器和 JVM 会在 <code>&lt;path-two&gt;\classes\com\runoob\test</code>中找 .class 文件。<br>一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。</p></li></ol><h3 id="5-设置CLASSPATH系统变量"><a href="#5-设置CLASSPATH系统变量" class="headerlink" title="5. 设置CLASSPATH系统变量"></a>5. 设置CLASSPATH系统变量</h3><p><strong>用下面的命令显示当前的CLASSPATH变量：</strong></p><ul><li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH</li><li>UNIX 平台（Bourne shell 下）：# echo $CLASSPATH</li></ul><p><strong>删除当前CLASSPATH变量内容：</strong></p><ul><li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH=</li><li>UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH</li></ul><p><strong>设置CLASSPATH变量:</strong><br>Windows 平台（DOS 命令行下）：<code>C:\&gt; set CLASSPATH=C:\users\jack\java\classes</code><br>UNIX 平台（Bourne shell 下）：<code># CLASSPATH=/home/jack/java/classes; export CLASSPATH</code></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼——类与对象</title>
      <link href="/2019/04/02/yao-dian-ti-lian-lei-yu-dui-xiang/"/>
      <url>/2019/04/02/yao-dian-ti-lian-lei-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="一-类"><a href="#一-类" class="headerlink" title="一. 类"></a>一. 类</h2><h3 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1. 类的定义"></a>1. 类的定义</h3><p>在Java中，类是一种引用型数据类型。类是一种现实世界的事物的抽象，它包含了事物的<strong>属性</strong>和<strong>行为</strong><a href></a>,对应类中的<strong>属性</strong>和<strong>方法</strong><br>java语言的类的格式：</p><pre><code> [修饰符] class 类名 {    类体 }</code></pre><pre><code>public class Dog{   String breed;   int age;   String color;   void barking(){   }   void hungry(){   }   void sleeping(){   }}</code></pre><blockquote><p>在Java语言中，Java的所用东西都要在类中实现。</p></blockquote><h3 id="2-类体"><a href="#2-类体" class="headerlink" title="2. 类体"></a>2. 类体</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>一个类中可以包含以下类型变量</p><ul><li><strong>局部变量：</strong>在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量：</strong>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量：</strong>类变量也声明在类中，方法体之外，但必须声明为static类型。</li></ul><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>类中设置的方法，Java建议类的成员方法的修饰符使用<code>private</code>。Java在调用方法的时候可以用类的实例化对象调用方法,如：<code>new 类名().方法名()</code></p><ul><li><strong>实例方法:</strong> </li></ul><pre><code>[修饰符] 返回值类型 成员方法名（参数列表）[throws 异常类型列表] {     成员方法体}</code></pre><ul><li><p><strong>成员方法的重载</strong><br>所谓的成员方法的重载是指在一个类中，同一个名称的成员方法可以被多次定义的现象，在每一个方法的参数类型和个数都不同。</p></li><li><p><strong>构造方法</strong><br>构造方法是在构造类的对象是使用的方法，其主要的作用就是初始化成员变量。构造方法不需要返回任何值，它在构造类对象时自动调用。构造方法也可以重载。注意：构造方法名和类名必须相同。</p><pre><code>[修饰符] 类名(参数列表)</code></pre></li></ul><p>通常一个类中应该包含的成员方法：</p><ul><li><strong>构造方法：</strong>至少包含一个不带参数的构造方法与一个带完整参数的构造方法</li><li><strong>更改器：</strong>可以保证在对象创建之后，可以更改对象的状态</li><li><strong>获取器：</strong>可以保证随时获得对象的状态值</li><li><strong>toString：</strong>将对象的状态值转换为字符串</li><li><strong>equals：</strong>实现判断两个对象是否相等</li></ul><h3 id="3-类之间的关系"><a href="#3-类之间的关系" class="headerlink" title="3. 类之间的关系"></a>3. 类之间的关系</h3><blockquote><p>类之间的关系可以归结为3类：依赖、聚合和继承</p></blockquote><ul><li>依赖：A类成员方法调用B类的成员方法</li><li>聚合：类A的对象包含类B的对象</li><li>继承：类A继承于类B，即类B中有类A的全部成员变量和成员方法</li></ul><h2 id="二-对象"><a href="#二-对象" class="headerlink" title="二. 对象"></a>二. 对象</h2><blockquote><p>对象是类的一个实例，有状态和行为。</p></blockquote><h3 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1. 创建对象"></a>1. 创建对象</h3><ul><li>定义对象的语法格式：</li></ul><pre><code>[修饰符] 类名 对象名;Data data;</code></pre><ul><li>创建对象</li></ul><pre><code>new 类名(参数列表);new Data(10);</code></pre><ul><li>定义创建对象也可以放在一起进行</li></ul><pre><code>Time time = new Time(10);</code></pre><p><strong>new运算符主要完成两项工作：</strong></p><ol><li>为对象分配内存空间</li><li>根据提供的参数格式调用与之匹配的构造方法，实现初始化成员变量的操作，然后返回对象的引用</li></ol><h3 id="2-对象成员的引用"><a href="#2-对象成员的引用" class="headerlink" title="2. 对象成员的引用"></a>2. 对象成员的引用</h3><pre><code>对象名.成员变量;对象名.成员方法(参数列表)</code></pre><h3 id="3-对象的清除"><a href="#3-对象的清除" class="headerlink" title="3. 对象的清除"></a>3. 对象的清除</h3><p>在Java中，对象的收回是通过Java虚拟机自动收回的，不用我们操心。</p><h2 id="三-访问特性控制"><a href="#三-访问特性控制" class="headerlink" title="三. 访问特性控制"></a>三. 访问特性控制</h2><blockquote><p>Java语言是通过控制标识符来控制类、数据、方法和接口的共享的，Java提供了四种访问特性控制符：</p><ol><li>默认访问特性</li><li>public（公有）访问特性</li><li>private （私有）访问特性</li><li>protected （保护）访问特性</li></ol></blockquote><h3 id="1-默认访问特性"><a href="#1-默认访问特性" class="headerlink" title="1. 默认访问特性"></a>1. 默认访问特性</h3><p>如果在定义类、接口、成员变量与成员方法时没有定义访问特性，那么Java默认他的访问特性为默认访问特性。具有默认访问特性的类、接口、成员变量与成员方法，只能被本类和同一个包中的其他类、接口接成员方法应用。（他可以阻止其他包任何形式的引用。）</p><h3 id="2-public访问特性"><a href="#2-public访问特性" class="headerlink" title="2. public访问特性"></a>2. public访问特性</h3><p>public访问特性最具有开放性，没有任何访问限制。<br>通常会将公共类或者作为公共接口的的成员方法指定为public访问特性；建议不要将成员变量设置为public，否则会破坏代数据的隐藏性。</p><h3 id="3-private访问特性"><a href="#3-private访问特性" class="headerlink" title="3. private访问特性"></a>3. private访问特性</h3><p>将数据与操作封装在一起，并将数据的组织隐藏起来，利用成员方法作为对外的操作接口。这样不当可以提高程序的安全性和可靠性，还有有益于日后的维护、扩展和重用。<br>这种访问特性实现数据隐藏的最佳方式。<br>应用于类成员。只能被本类直接引用。</p><h3 id="4-protected访问特性"><a href="#4-protected访问特性" class="headerlink" title="4. protected访问特性"></a>4. protected访问特性</h3><p>可以被本类、本包中的其他类和其他包中的子类访问。他的访问特性介于默认和public之间。</p><blockquote><p>小技巧：如何阅读代码<br>作为一个程序员，面对一段从未见识过的代码，不必每行代码都细读（当然，这也不可能，真正的项目里代码有万千行，你自己读读试试），只需要将代码按照结构分成不同段，大致了解每一部分代码的事项的功能即可。比如，一段Java代码，按照类分成不同的部分，基本一段好的程序，从类的名字中就能知道这个类的作用的。</p></blockquote><h2 id="四-内部类"><a href="#四-内部类" class="headerlink" title="四. 内部类"></a>四. 内部类</h2><p>Java的类是允许嵌套的，嵌套在一个类内部的被称为<strong>内部类</strong>。没有嵌套在任何类中的类被称为顶层类。</p><h2 id="五-类的静态成员"><a href="#五-类的静态成员" class="headerlink" title="五. 类的静态成员"></a>五. 类的静态成员</h2><p>Java语言提供了两种形式的成员：</p><ul><li>静态成员</li><li>实例成员（非静态）</li></ul><h3 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h3><ul><li>在分文修饰符之后加上static修饰符就称为静态成员变量。例如：<code>public static int staticMember</code></li><li>静态成员变量值在家在类是创建一个副本，无论未来创建同一个类的多少个对象都将共享同一个副本。</li></ul><h3 id="2-静态成员方法"><a href="#2-静态成员方法" class="headerlink" title="2. 静态成员方法"></a>2. 静态成员方法</h3><h2 id="六-可编辑字符串类"><a href="#六-可编辑字符串类" class="headerlink" title="六. 可编辑字符串类"></a>六. 可编辑字符串类</h2><p>可编辑的字符串类：StringBuffer<br>StringBuffer类滴哦你故意在java.lang包中，其中包含以下3个private成员变量</p><ul><li>private char value[]：存放字符串的缓冲区</li><li>private int count：缓冲区中存放字符的个数</li><li>private boolean shared：缓冲区是否共享的标志</li></ul><p>另外，另外还提供了3个构造方法：</p><ul><li>public stringBuffer();  默认缓冲区的大小为16个字符</li><li>public stringBuffer(int length); 缓冲区的大小为length个字符</li><li>public stringBuffer(String str); 缓冲区的大小为字符串str的长度加上16，并将str存入缓冲区</li></ul><p><strong>StringBuffer用于获取可变字符串相应信息的public成员方法：</strong></p><ol><li>ing length() 返回当前可变字符床的长度</li><li>int capacity() 放回当前缓冲区的大小</li><li>char charAt(int index） 返回下标为index的位置的字符串，第一个字符的下标为0.（如果index非法将抛出IndexOutOfBoundsException异常）</li><li>void getChars(int sreBegin, int srcEnd, char dst[], int destBegin) 获取从sreBegin到srcEnd的字符串，并存入dst数组中，在dst中的起始位置为dstBegin。如果srcBegin和srcEnd非法将抛出StringIndexOutOfBoundsException异常</li><li>String substring(int start, int end) 返回从start到end的字符串</li><li>int indexOf(String str, int fromIndex) 返回字符串str在缓冲区从fromIndex开始，第一次出现的手字符的下标。</li><li>String toString(）将StringBuffer内容转换成String形式输出</li><li>void setChar(int index, char ch)将字符串中下标为index的字符设置为ch</li><li>StringBuffer append(obj) 这个成员方法利用String类中的ValueOf(）方法，将obj转换成字符串，并将这些字符串追加到缓冲区的尾部</li><li>StringBuffer delete(int start，int end) 删除缓冲区start到end的所有字符</li><li>StringBuffer replace(int start, int end, String str）将str字符串替换从start～end-1 的字符串并返回修改后的StringBuffer对象</li><li>StringBuffer insert(int index, char str[], int offset, int len) 将str数组从0ffset开始，长度为len的字符串插入到缓冲区从index起始的位置处</li><li>StringBuffer inset(int offset, Object obj) 将obj字符串插入到缓冲区偏移量为offset的位置处。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渝中召开领导干部大会 传达学习陈敏尔书记参加渝中代表团审议时的讲话精神</title>
      <link href="/2019/03/26/yu-zhong-zhao-kai-ling-dao-gan-bu-da-hui/"/>
      <url>/2019/03/26/yu-zhong-zhao-kai-ling-dao-gan-bu-da-hui/</url>
      
        <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/OHD6z6fDlM9822fpn79tIribC0iaaH1QkzDAX4klv2ePEm8FsXkiatrChPP3NnrjLmngQ88zL0YIJc9DqamF6icseA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt></p><blockquote><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2kfkimtj30u00gwkfp.jpg" alt><br>今（1）日，渝中召开领导干部大会，传达学习市委书记陈敏尔在参加渝中代表团审议时的讲话精神。渝中区委书记黄玉林出席会议并讲话，区委副书记、区长商奎，区人大常委会主任米绍林，区政协主席陈大奎，区委副书记何家利以及全体在家区级领导，全区正处级以上领导干部参加会议。</p></blockquote><blockquote><p>黄玉林指出，陈敏尔书记到渝中代表团参加审议，是对渝中工作的关心和厚爱，是对全区干部群众凝心聚力、砥砺奋进推进高质量发展、创造高品质生活的有力鞭策。全区上下一定要认真学习领会、深入贯彻落实陈敏尔书记参加渝中代表团审议时的讲话精神，全力以赴推动市委要求在渝中落实落地。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2l3w53ij30u00gw4hn.jpg" alt><br>黄玉林强调，要深刻领会把握陈敏尔书记关于“紧紧围绕习近平总书记对重庆提出的重要指示要求，进一步提高政治站位和战略站位，增强战略谋划力、战役执行力”的指示精神，把准方向保持定力，确保中央要求和市委部署率先在渝中落地生根、开花结果。要自觉维护习近平总书记党中央的核心、全党的核心地位，维护党中央权威和集中统一领导，牢固树立“四个意识”，坚定“四个自信”，以实际行动兑现市委“三个确保”的政治承诺。要深学笃用习近平新时代中国特色社会主义思想，把总书记对重庆的殷殷嘱托领会好，始终沿着总书记指引的方向前进。要按照陈敏尔书记“学在深处、谋在新处、干在实处、走在前列”要求，把总书记对重庆提出的“两点”定位、“两地”“两高”目标和营造良好政治生态、做到“四个扎实”的重要指示要求，落实为渝中行动，转化为实在成效。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1m2m4y131j30u00mi1kx.jpg" alt><br>黄玉林强调，要深刻领会把握陈敏尔书记关于“把构建现代产业体系作为城市发展的重要支撑”的指示要求，坚定方向突出重点，创新发展金融业，优化发展高端商贸业，融合发展文化旅游业，升级发展康养产业，用好优势医疗、教育资源，推动现代服务业创新升级发展。要深刻领会把握陈敏尔书记“大力推进社会治理现代化，贯彻以人民为中心的发展思想，让人民群众在城市生活更方便、更舒心、更美好”的指示要求，夯实基层强化基础，把安全放在城市管理服务第一位，增强城市管理服务的人文关怀，创新城市管理服务方式方法，全面提高城市管理服务水平。要深刻领会把握陈敏尔书记对渝中经济社会发展成绩的肯定，增强信心坚定决心，把市委市政府对渝中的肯定转化为发展的强大动力，牢记中心城区职责使命不动摇，顺应城市工作新形势、改革发展新要求、人民群众新期待，不断奋发有为、担当作为，着力打造适应服务业发展现代化和社会治理现代化要求的高素质干部队伍，凝聚起推动渝中高质量发展的强大合力。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼——数组与字符串</title>
      <link href="/2019/03/26/yao-dian-ti-lian-shu-zu-yu-zi-fu-chuan/"/>
      <url>/2019/03/26/yao-dian-ti-lian-shu-zu-yu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h2><h3 id="1-1-一维数组"><a href="#1-1-一维数组" class="headerlink" title="1.1 一维数组"></a>1.1 一维数组</h3><h4 id="1-一维数组的声明方法："><a href="#1-一维数组的声明方法：" class="headerlink" title="1. 一维数组的声明方法："></a>1. 一维数组的声明方法：</h4><pre><code>int[] a = new int[n];   //表示a[]是有n个元素的整形数组</code></pre><p><strong>强制：声明数组时,强制[]放在基本数据类型后面，不要放在变量后面。放在基本数据类型后面表示声明一个int类型的数组。</strong></p><h4 id="2-一维数组初始化："><a href="#2-一维数组初始化：" class="headerlink" title="2. 一维数组初始化："></a>2. 一维数组初始化：</h4><ul><li><strong>静态初始化</strong>：<code>int[] a = {1,2,3,4};</code></li><li><strong>动态初始化</strong>：<code>a[0] = 3;</code></li></ul><h4 id="3-一维数组元素的访问："><a href="#3-一维数组元素的访问：" class="headerlink" title="3. 一维数组元素的访问："></a>3. 一维数组元素的访问：</h4><p>数组的元素是通过索引访问的。数组索引从0开始，所以索引值从0到arrayRefVar.length-1。</p><pre><code>a[index]; //其中index为数组下标，表示数组中第index-1个存储空间。</code></pre><h3 id="1-2-二维数组"><a href="#1-2-二维数组" class="headerlink" title="1.2 二维数组"></a>1.2 二维数组</h3><h4 id="二维数组声明方法："><a href="#二维数组声明方法：" class="headerlink" title="二维数组声明方法："></a>二维数组声明方法：</h4><pre><code>int[][] a = new int[m][n];  //m，n为数组下标</code></pre><h4 id="数组初始化："><a href="#数组初始化：" class="headerlink" title="数组初始化："></a>数组初始化：</h4><ul><li><strong>静态初始化：</strong></li></ul><pre><code>int[][] a = {             {1,2,3},             {4,5,6},             {7,8,9}};</code></pre><ul><li><strong>动态初始化：</strong></li></ul><pre><code>int[][] a = new int[m][n]; a[0][1] = 4;   //动态的分别给字符串的每一个元素赋值</code></pre><h4 id="二维数组的访问："><a href="#二维数组的访问：" class="headerlink" title="二维数组的访问："></a>二维数组的访问：</h4><p>二维数组的访问和一维数组的访问类似</p><h2 id="2、字符串"><a href="#2、字符串" class="headerlink" title="2、字符串"></a>2、字符串</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2019/03/21/yao-dian-ti-lian-java-ji-chu/"/>
      <url>/2019/03/21/yao-dian-ti-lian-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JAVA基本语法"><a href="#1-JAVA基本语法" class="headerlink" title="1. JAVA基本语法"></a>1. JAVA基本语法</h2><p>编写Java程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass(驼峰命名法) 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写（驼峰命名法）。</li><li><strong>源文件名</strong>：<strong>源文件名必须和类名相同</strong>。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>主方法入口</strong>：所有的Java程序由<code>public static void main(String args[])</code>方法开始执行。</li></ul><h2 id="2-JAVA编程格式"><a href="#2-JAVA编程格式" class="headerlink" title="2. JAVA编程格式"></a>2. JAVA编程格式</h2><pre><code>import java.util.Scanner;public class Main {    public static void main(String[] args) throws Exception{        System.out.println(config.a + config.b);        Scanner in = new Scanner(System.in);        int a = in.nextInt();        System.out.println(a);    }}</code></pre><h2 id="3-JAVA数据类型"><a href="#3-JAVA数据类型" class="headerlink" title="3. JAVA数据类型"></a>3. JAVA数据类型</h2><h3 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h3><p>byte、char、short、int、long、float、double、boolean</p><table><thead><tr><th>数据类型</th><th>类别</th><th>位数</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>8位</td><td>-2^7 ～ 2^7-1</td><td>0</td></tr><tr><td>char</td><td>字符型</td><td>16位</td><td>\u0000 ～ \uffff (0~65535)</td><td>0</td></tr><tr><td>short</td><td>短整型</td><td>16位</td><td>-2^15 ～ 2^15-1</td><td>0</td></tr><tr><td>int</td><td>整型</td><td>32位</td><td>-2^31 ～ 2^31-1</td><td>0</td></tr><tr><td>long</td><td>长整型</td><td>64位</td><td>-2^63 ～ 2^63-1</td><td>0L</td></tr><tr><td>float</td><td>单精度浮点型</td><td>32位</td><td>-3.4 X 10^38 ～ 3.4 X 10^38</td><td>0.0f</td></tr><tr><td>double</td><td>双精度浮点型</td><td>64位</td><td>-1.7 X 10^308 ～ 1.7 X 10^308</td><td>0.0d</td></tr><tr><td>boolean</td><td>布尔类型</td><td></td><td>true、false</td><td>false</td></tr></tbody></table><h3 id="3-2-数据类型转换规则"><a href="#3-2-数据类型转换规则" class="headerlink" title="3.2 数据类型转换规则"></a>3.2 数据类型转换规则</h3><p>JAVA中的数据类型在定义时就已经确定了，不能随意改变。但是JAVA允许有限度的进行类型转换处理：<strong>自动类型转换</strong>、<strong>强制类型转换</strong><br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1arnl1y66j315q0nowgk.jpg" alt></p><h4 id="3-2-1-自动类型转换"><a href="#3-2-1-自动类型转换" class="headerlink" title="3.2.1 自动类型转换"></a>3.2.1 自动类型转换</h4><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1fvxqrpgtj32xj16mx6t.jpg" alt></p><h4 id="3-2-2-强制类型转换"><a href="#3-2-2-强制类型转换" class="headerlink" title="3.2.2 强制类型转换"></a>3.2.2 强制类型转换</h4><p>将高级数据转换成低级数据，只能用强制类型转换，通常在要求强制类型转换的变量名前用()括号上所要强制转换的类型符号。如：</p><pre><code>short s；byte b = (byte)s;</code></pre><h2 id="4-直接量、常量与变量"><a href="#4-直接量、常量与变量" class="headerlink" title="4. 直接量、常量与变量"></a>4. 直接量、常量与变量</h2><ul><li><strong>直接量</strong>：就是数据类型的数值，如int型：3就是直接量</li><li><strong>常量</strong>：特定标识符表示的直接量，赋值之后就不可以更改：<pre><code>[修饰符] final 数据类型 常量标识符 [= 直接量]public final int a = 3;</code></pre></li><li><strong>变量</strong>：存储数据的特定标识符，可以更改存储的数据：<pre><code>数据类型 常量标识符 [= 直接量]int a = 3;</code></pre></li></ul><h2 id="5-JAVA的输入输出方式"><a href="#5-JAVA的输入输出方式" class="headerlink" title="5. JAVA的输入输出方式"></a>5. JAVA的输入输出方式</h2><ul><li><strong>输入</strong>：Java的输入是通过Scanner类实现的，在时用Scanner类时要在项目最顶端倒入Scanner类，如：import java.util.Scanner;</li></ul><pre><code>Scanner scan = new Scanner(System.in) // System.in是系统的System类的输入流int a = scan.nextInt();</code></pre><p>nextInt是Scanner类的一个读取数据的成员方法。Scanner类内部定义了许多的成员方法用于读取不同数据类型的数据：<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g1fxdwk2kvj32zn1f2qvb.jpg" alt></p><ul><li><strong>输出</strong>：Java的最简单的输出方式：<pre><code>System.out.print(&quot;Hello World:&quot; + a);</code></pre><strong>注意“+”</strong>：+在里面充当连接符的角色，但是当两个基本数据类型的变量被+连接时，他们会进行加操作；字符串和数据类型变量被+连接时，数据类型变量会自动转换成字符串。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 要点提炼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要点提炼-View的事件体系</title>
      <link href="/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/"/>
      <url>/2019/03/11/yao-dian-ti-lian-view-de-shi-jian-ti-xi/</url>
      
        <content type="html"><![CDATA[<p><strong>View是Android中的所有控件的基类，所有的控件都是直接或间接继承自View，所以View在Android中是一个很重要的概念。本篇将简要介绍View。<br>内容如下：</strong></p><ul><li>Android UI界面架构</li><li>View的基础知识</li><li>View的滑动</li><li>弹性滑动</li><li>View的事件分发机制</li><li>View的滑动冲突</li></ul><hr><h3 id="一、Android-UI界面架构"><a href="#一、Android-UI界面架构" class="headerlink" title="一、Android UI界面架构"></a>一、Android UI界面架构</h3><p>讲View之前先涉及一点Android的UI结构，后面的View分发机制会涉及一点这里的知识。<br>每个Activity包含一个<code>PhoneWindow</code>对象，<code>PhoneWindow</code>设置<code>DecorView</code>为应用的根视图（顶级视图）。在里面就是我们熟悉的<code>TitleView</code>和<code>ContentView</code>。<code>titleView</code>的位置就是我们那平常看到的App的标题栏，而我们平时在Activit中使用的<code>setContentView（）</code>就是设置<code>ContentView</code>。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrn2iri7j30ve0g0k2g.jpg" alt></p><h3 id="二、View的基础知识"><a href="#二、View的基础知识" class="headerlink" title="二、View的基础知识"></a>二、View的基础知识</h3><h4 id="1、什么是View"><a href="#1、什么是View" class="headerlink" title="1、什么是View"></a>1、什么是View</h4><p><strong>View：</strong>它是一种界面层的控价的一种抽象，它代表了一个控价。Android中的所有的控件都继承自它。<br><strong>ViewGroup：</strong>顾名思义这是一个View的组合，它内部包含了多个View。ViewGroup也继承了View，这就意味着View本身就可以是单个控件也可以是多个控价组成的一组控件。<br>从某种角度讲，Android中的控价可以分为两大类：View和ViewGroup。通过ViewGroup，整个界面可以组成一个View树，上层的View要负责下层View的测量与绘制，并传递事件。<br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zrnrvi8aj30j60b3dj1.jpg" alt></p><h4 id="2、View的位置参数"><a href="#2、View的位置参数" class="headerlink" title="2、View的位置参数"></a>2、View的位置参数</h4><p>a. Android坐标系：以屏幕左上角为坐标原点，<strong>向右</strong>为x轴正方向，<strong>向下</strong>为y轴正方向。<br>b. View的位置主要由它的四个顶点决定：top、left、right、bottom</p><ul><li>top：左上角的纵坐标</li><li>left：左上角的横坐标</li><li>right：右下角的横坐标</li><li>bottom：右下角的纵坐标<br><strong>这些都是相对于View的父容器而言的，是一种相对坐标</strong><br><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zro3hdndj30c50bkq42.jpg" alt><br>由上图就很容易的得到View的宽高和坐标的关系：<pre><code>width = right - leftheight = bottom - top</code></pre>我们了解了上述View属性，那我们怎么获取这些属性呢。别着急，其实View还提供了get方法帮助我们获取上述属性。</li><li>left = getLeft()</li><li>Right = getRight()</li><li>top = getTop()</li><li>bottom = getBottom</li><li>width = getWidth</li><li>height = getHeight</li></ul><p>c.从Android3.0开始，View增加了额外的几个参数：x、y、translationX、translationY。<br>其中x和y是View左上角的坐标，translationX和translationY是View的左上角相对于父容器的偏移量，他们的默认值均为0。和View的基本属性一样，这些参数也是相对于View父容器的，而且View也提供了set/get方法。</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g0zroc04s9j30kl0hd788.jpg" alt></p><blockquote><p>x = left + translationX<br>y = top + translationY</p></blockquote><p><strong>注意：</strong> View在移动的过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x、y、translationX和translationUY这四个参数。另外在onCreate()方法里面无法获取到View的坐标参数，这是因为此时的View还未开始绘制，全部的坐标参数都将是0。</p><h4 id="3-MotionEvent和TouchSlop"><a href="#3-MotionEvent和TouchSlop" class="headerlink" title="3. MotionEvent和TouchSlop"></a>3. MotionEvent和TouchSlop</h4><h5 id="1-MotionEvent"><a href="#1-MotionEvent" class="headerlink" title="1.MotionEvent"></a>1.MotionEvent</h5><p>在手指接触屏幕后所产生的一系列的事件，典型的事件类型有：</p><ul><li>ACTION_DOWN -—— 手指接触屏幕</li><li>ACTION_MOVE -—— 手指在屏幕上移动</li><li>ACTION_UP ———— 手指从屏幕上松开的一瞬间<br>正常情况下，一次手指接触屏幕的行为就会触发一系列的事件，列出两种典型情况：</li><li>点击屏幕后松开：ACTION_DOWN -&gt; ACTION_UP</li><li>点击屏幕后滑动一段距离松开：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_UP</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5494434-1fe5babc389caa90?imageMogr2/auto-orient/" alt></p><p><strong>在Android中所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、历史记录、第几个手指等，所以我们可以通过MotionEvent对象来得到点击事件的x和y坐标。为此系统提供了两组方法：getX/getY和getRawX/getRawY。</strong></p><ul><li>getX/getY: 返回相当于当前View左上角的坐标</li><li>getRawX/getRawY: 放回对于手机屏幕左上角的坐标 </li></ul><p>具体关系如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5494434-825bc5992190e5e8?imageMogr2/auto-orient/" alt></p><h5 id="2-TouchSlop"><a href="#2-TouchSlop" class="headerlink" title="2. TouchSlop"></a>2. TouchSlop</h5><p>TouchSlops是系统所能识别出来的滑动的最小的距离。即这是一个常量，当手机在屏幕上的滑动距离小于这个常量的时候，系统就不会认为这是一个滑动操作。这个常量和设备有关，在不同的设备上有不同的值，我们可以通过<code>ViewConfiguration.get(get(context)).getScaledTouchSlop()</code>获取到这个常量。</p><h4 id="4-VelocityTracker、GestureDetector和Scroller"><a href="#4-VelocityTracker、GestureDetector和Scroller" class="headerlink" title="4. VelocityTracker、GestureDetector和Scroller"></a>4. VelocityTracker、GestureDetector和Scroller</h4><h5 id="1-VelocityTracker"><a href="#1-VelocityTracker" class="headerlink" title="1. VelocityTracker"></a>1. VelocityTracker</h5><p>–速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。<br>使用过程：首先在View的<code>onTouchEvent</code>方法中追踪当前事件的速度：</p><pre><code>VelocityTracker mVelocityTracker = VelocityTracker.obtain();mVelocityTracker.addMovement(event);</code></pre><p>接着，在<strong>ACTION_MOVe</strong>事件中获取当前的速度：</p><pre><code>mVolocityTracker.computeCurrenVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity();float yXelocity = mVelocityTracker.getYVelocity();</code></pre><p>最后，当不需要使用它是，需要调用clear方法来重置并回收内存：</p><pre><code>mVelocityTracker.clear();mVelocityTracker.recycle();</code></pre><p><strong>注意这里计算的速度值为1000ms时间间隔移动的像素值，假设移动了100像素，速度就是100像素/秒</strong></p><h5 id="2-GestureDetector"><a href="#2-GestureDetector" class="headerlink" title="2. GestureDetector"></a>2. GestureDetector</h5><p>–手势检测。用于辅助检测用户的点击、滑动、长按、双击等行为。<br>使用过程：<br>创建一个<code>GestureDetector</code>对象并实现<code>onGestureLister</code>接口，根据需要是想点击方法：</p><pre><code>GestureDetector mGestureDetector = new GestureDetector(this);mGestureDetector.setIsLongpressEnabled(false);  //解决长按屏幕后无法实现拖动的现象</code></pre><p>接着，接管目标<code>View</code>的<code>onTouchEvent</code>方法，在待监听View的<code>onTouchEvent</code>方法中添加如下实现：</p><pre><code>boolean consume = mGestureDetector.onTouchEvent(event);return consume;</code></pre><p>做完上面两步我们就可以有选择的实现OnGestureListener和OnDoubleTapListener中的方法了,OnGestureListener和OnDoubleTapListener接口中的方法：</p><table><thead><tr><th>方法名</th><th>描述</th><th>所属接口</th></tr></thead><tbody><tr><td>onDown</td><td>手指轻轻接触屏幕的一瞬间，只有一个ACTION_DOWN</td><td>OnGestureListener</td></tr><tr><td>onShowPress</td><td>手指轻轻触摸屏幕，尚未松开或拖动， 由1个ACTION_DOWN触发</td><td>OnGestureListener</td></tr><tr><td>onSingleTopUp</td><td>手指（轻轻触摸屏幕后）松开，伴随着一个ACTION_UP触发（这是点击行为）</td><td>OnGestureListener</td></tr><tr><td>onScroll</td><td>手指按下屏幕并拖动，由1个ACTION_DOWN和多个ACTION_MOVE触发（这是拖动功能）</td><td>OnGestureListener</td></tr><tr><td>onLongPress</td><td>用户长按屏幕</td><td>OnGestureListener</td></tr><tr><td>onFling</td><td>用户触摸屏幕、快速的滑动后松开，由1个ACTION_DOWN、多个ACTION_MOVE和1个ACTION_UP触发，这是快速滑动行为</td><td>OnGestureListener</td></tr><tr><td>onDoubleTap</td><td>双击，由2个ACTION_DOWN触发，他不能和onSingleTapConfirmed共存</td><td>onDoubleTapListener</td></tr><tr><td>onSingleTapConfirmed</td><td>严格的点击行为</td><td>onDoubleTapListener</td></tr><tr><td>onDoubleTapEvent</td><td>表示发生了双击行为，在双击的期间，ACTION_DOWN、ACTION_MOVE、ACTION_UP都会触发次回调</td><td>onDoubleTapListener</td></tr></tbody></table><blockquote><p>在实际开发中可以不使用GestureDetector，完全可以自己在onTouchEvent中实现所需的监听。另外，如果知识监听滑动相关的，建议自己在onGestureDetector中实现，如果要监听双击这种行为的话，就使用GestureDetecter。</p></blockquote><h5 id="3-Scroller"><a href="#3-Scroller" class="headerlink" title="3. Scroller"></a>3. Scroller</h5><p>弹性滑动，用于实现View的弹性滑动。<br>当时使用scrollTo/scrollBy滑动时，滑动是瞬间完成的，这样的滑动效果看起来没有流畅感。这个时候就需要使用Scroller来实现由过渡效果的滑动。Scroller的话送不是瞬间完成的，它是在一定时间间隔内完成的。Scroller本身不能使View滑动，它需要配合View的computeScroll方法才能共同完成View的滑动。下面是一个简单的实现弹性滑动的代码：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();    int delta = destX - scrollX;    //1000ms内滑向destX，效果就是慢慢滑动    mScroller.startScroll(scrollX, 0, delta, 0, 1000);    invalidate();}@Overridepublic void computeScroll() {    if(mScroller.computeScrollOffSet()) {        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());        postInvalidate();    }}</code></pre><h3 id="三、View的滑动"><a href="#三、View的滑动" class="headerlink" title="三、View的滑动"></a>三、View的滑动</h3><blockquote><p><strong>实现View滑动的三种方式：</strong></p><ol><li>通过View本身提供的scrollTo/scrollBy方法</li><li>通过动画给View施加平移效果</li><li>通过改变View的LayoutParams使得View重新布局</li></ol></blockquote><h4 id="1-使用scrollTo-scrollBy"><a href="#1-使用scrollTo-scrollBy" class="headerlink" title="1. 使用scrollTo/scrollBy"></a>1. 使用scrollTo/scrollBy</h4><p>为了实现View的滑动，Vie提供了专门的方法实现这个功能：scrollTo和scrollBy<br><strong>scrollTo()</strong>:在当前视图内容偏移至(x , y)坐标处，即显示(可视)区域位于(x , y)坐标处。</p><pre><code>/** * Set the scrolled position of your view. This will cause a call to * {@link #onScrollChanged(int, int, int, int)} and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */    public void scrollTo(int x, int y) {        //偏移位置发生了改变        if (mScrollX != x || mScrollY != y) {              int oldX = mScrollX;            int oldY = mScrollY;            mScrollX = x;  //赋新值，保存当前便宜量            mScrollY = y;            //回调onScrollChanged方法            onScrollChanged(mScrollX, mScrollY, oldX, oldY);            if (!awakenScrollBars()) {                invalidate();  //一般都引起重绘            }        }    }</code></pre><p><strong>scrollBy():</strong>：在当前视图内容继续偏移(x , y)个单位，显示(可视)区域也跟着偏移(x,y)个单位。</p><pre><code> /**       * Move the scrolled position of your view. This will cause a call to       * {@link #onScrollChanged(int, int, int, int)} and the view will be       * invalidated.       * @param x the amount of pixels to scroll by horizontally       * @param y the amount of pixels to scroll by vertically       */      // 看出原因了吧 。。 mScrollX 与 mScrollY 代表我们当前偏移的位置 ， 在当前位置继续偏移(x ,y)个单位      public void scrollBy(int x, int y) {          scrollTo(mScrollX + x, mScrollY + y);      }</code></pre><p><strong>总结:scrollTo()指的是移动到制定的(x,y)位置，而scrollBy(x,y)指的是，在当前位置在移动(x,y)个位置</strong></p><p>mScrollX和mScrollY分别表示View在X、Y方向的滚动距离。mScrollX：View的左边缘减去View的内容的左边缘；mScrollY：View的上边缘减去View的内容的上边缘。从右向左滑动，mScrollX为正值，反之为负值；从下往上滑动，mScrollY为正值，反之为负值。（更直观感受：查看下一张照片或者查看长图时手指滑动方向为正）</p><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g10db9qbgdj30jg0dracq.jpg" alt></p><h4 id="2-使用动画"><a href="#2-使用动画" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p> 这节我们讲解如何使用动画来移动View，主要操作是View的<code>translationX</code>和<code>translationY</code>的属性,既可以采用传统的View动画，也可以采用属性动画（如果使用属性动画的话，为了能够兼容3.0以下的版本，需要采用开源动画<code>nineoldandroids</code>(<a href="http://nineoldandroids.com/）" target="_blank" rel="noopener">http://nineoldandroids.com/）</a><br> 采用View动画代码，如下所示。此动画可以在100ms内将一个View从原始位置向右下角移动100个像素。</p><pre><code> &lt;?xml veision=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:fillAfter=&quot;true&quot;    android:zAdjustment=&quot;normal&quot;&gt;    &lt;translate         android:duration=&quot;100&quot;        android:fromXDelta=&quot;0&quot;        android:fromYDelta=&quot;0&quot;        android:interpolator=&quot;@android:anim/linear_interpolator&quot;        android:toXDelata=&quot;100&quot;        android:toYDelata=&quot;100&quot;/&gt;&lt;/set&gt;</code></pre><p> 采用属性动画就更简单了：</p><pre><code> ObjectAnimator.ofFloat(targetView, &quot;translationX&quot;, 0, 100).setDuration(100).start();</code></pre><p>View动画是对View的影像的操作，他并不能真正改变View的参数，包括宽/高，并且如果希望动画移动后的状态保留还必须讲<code>fillAfter</code>属性设置为true。而属性动画并不存在上述的问题，但是在Android3.0以下就不能使用属性动画了。</p><h4 id="3-使用LayoutParams将一个View重新布局"><a href="#3-使用LayoutParams将一个View重新布局" class="headerlink" title="3.使用LayoutParams将一个View重新布局"></a>3.使用LayoutParams将一个View重新布局</h4><p>比如将一个View向右移动100像素，向右，只需要把它的marginLeft参数增大即可，代码见下：</p><pre><code>MarginLayoutParams params = (MarginLayoutParams) btn.getLayoutParams();params.leftMargin += 100;btn.requestLayout();// 请求重新对View进行measure、layout//或btn.setLayoutParams(params);</code></pre><h4 id="4、各种滑动方式的比较"><a href="#4、各种滑动方式的比较" class="headerlink" title="4、各种滑动方式的比较"></a>4、各种滑动方式的比较</h4><ul><li>scrollTo/scrollBy：操作简单适合对View内容的滑动</li><li>动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</li><li>LayoutParams：操作稍微复杂，适合于有交互的View</li></ul><h3 id="四、弹性滑动"><a href="#四、弹性滑动" class="headerlink" title="四、弹性滑动"></a>四、弹性滑动</h3><p>上一节讲了View的滑动，但是这种直接滑动效果实在是太差了，这里我们学习如何实现渐进式滑动。虽然实现的方法有很多，但是基本思想都是一样的：将一次滑动分成若干次小的滑动，并在一定时间内完成。这里介绍三种实现方式：Scroller、Handler#postDelayed以及Thread#sleep。</p><h4 id="1-Scroller"><a href="#1-Scroller" class="headerlink" title="1.Scroller"></a>1.Scroller</h4><blockquote><ul><li>与scrollTo/scrollBy不同：scrollTo/scrollBy过程是瞬间完成的，非平滑；而Scroller则有过渡滑动的效果。</li><li>注意：Scoller本身无法让View弹性滑动，它需要和View的computerScroller方法配合使用。</li></ul></blockquote><p>再看一次Scroller的经典使用方法：</p><pre><code>Scroller mScroller = new Scroller(mContext);//缓慢滑动到指定位置private void smoothScrollTo(int destX, int destY) {    int scrollX = getScrollX();//View的左边缘到其内容左边缘的距离  int scrollY = getScrollY();//View的上边缘到其内容上边缘的距离  int deltaX = dstX - scrollX;//x方向滑动的位移量  int deltaY = dstY - scrollY;//y方向滑动的位移量  scroller.startScroll(scrollX, scrollY, deltaX, deltaY, 1000); //开始滑动  invalidate(); //刷新界面}@Override//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记public void computeScroll() {  if (scroller.computeScrollOffset()) {     scrollTo(scroller.getCurrX(), scroller.getCurY());    postInvalidate();//通过不断的重绘不断的调用computeScroll方法  }}</code></pre><p>工作原理：当我们构造一个Scroller对象并且调用他的startScroll方法时，Scroller内部其实什么也没有做，他只是保存了我们传递的几个参数，这几个参数从startScroll的源码里就能看出：</p><pre><code>public void startScroll(int startX,int startY,int dx,int dy,int duration){  mMode = SCROLL_MODE;  mFinished = false;  mDuration = duration;//滑动时间  mStartTime = AnimationUtils.currentAminationTimeMills();//开始时间  mStartX = startX;//滑动起点  mStartY = startY;//滑动起点  mFinalX = startX + dx;//滑动终点  mFinalY = startY + dy;//滑动终点  mDeltaX = dx;//滑动距离  mDeltaY = dy;//滑动距离  mDurationReciprocal = 1.0f / (float)mDuration; }</code></pre><blockquote><p><strong>具体过程：</strong>在MotionEvent.ACTION_UP事件触发时调用startScroll方法-&gt;马上调用invalidate/postInvalidate方法-&gt;会请求View重绘，导致View.draw方法被执行-&gt;会调用View.computeScroll方法，此方法是空实现，需要自己处理逻辑。具体逻辑是：先判断computeScrollOffset，若为true（表示滚动未结束），则执行scrollTo方法，它会再次调用postInvalidate，如此反复执行，直到返回值为false。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/0077HGE3ly1g110wgux3cj30vw0kq43j.jpg" alt></p><blockquote><p>Scroll的computeScrollOffset()根据时间的流逝动态计算一小段时间里View滑动的距离，并得到当前View位置，再通过scrollTo继续滑动。即把一次滑动拆分成无数次小距离滑动从而实现弹性滑动。</p></blockquote><h4 id="2-使用动画-1"><a href="#2-使用动画-1" class="headerlink" title="2. 使用动画"></a>2. 使用动画</h4><p>动画本身就是一种渐进的过程，因此通过动画来实现滑动天然就有一种弹性效果。</p><pre><code>ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start();//在100ms内使得View从原始位置向右平移100像素</code></pre><p>我们还可以利用动画的特性来实现一些动画无法实现的特效，还拿scrollTo来说,我们想模仿Scroller来实现View的弹性滑动。</p><pre><code>final int startX = 0;final int deltaY = 100;ValueAnimator animator = ValueAnimator.onInt(0, 1).setDuration(1000);animator.addUpdateListener(new AnimatorUpdateListener() {    @Override    public void onAnimatorUpdate(ValueAnimator animator) {        float fraction = animator.getAnimatedFraction();        mButton.scrollTo(startX+(int)(deltaX * fraction), 0);    }});animator.start();</code></pre><p>在上述代码中，动画的本质并没有作用在任何对象上，他只是在1000ms内完成了一个对象，真正起到滑动效果的是动画监听器的onAnimatorUpdate方法的scrollTo。利用这个特性，我们可以在动画的每一帧到来时获取动画完成比例，然后根据这个比例计算出当前View的滑动距离。</p><h4 id="3-使用延时策略"><a href="#3-使用延时策略" class="headerlink" title="3.使用延时策略"></a>3.使用延时策略</h4><blockquote><p>核心思想：通过发送一系列的延时信息从而达到一种渐进式的效果。使用Handler或View的postDelayed方法，也可以使用线程的sleep方法。</p></blockquote><ul><li>postDelayed：通过它在handleMessage内发送延时信息，然后在消息中进行View的滑动，如果接连不断的发送这种延时信息就可以完成弹性滑动的效果了。</li><li>sleep：通过while循环不断的滑动View和sleep，就可以实现弹性滑动效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 要点提炼——开发艺术探索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity生命周期</title>
      <link href="/2019/03/07/activity-sheng-ming-zhou-qi/"/>
      <url>/2019/03/07/activity-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-返回栈"><a href="#1-返回栈" class="headerlink" title="1.返回栈"></a>1.返回栈</h2><p>Android时使用任务（task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈。<br>栈是一种后进先出的数据结构。在默认情况下，每当我们启用一个新的活动时，这个活动就会放在返回栈的最顶层，当调用Back或finish（）时，返回栈的最顶层的活动就会出栈。<br><img src="http://upload-images.jianshu.io/upload_images/11542292-794b43f5902753c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-活动的状态"><a href="#2-活动的状态" class="headerlink" title="2.活动的状态"></a>2.活动的状态</h2><h3 id="每个活动在其生命周期里有4种状态。"><a href="#每个活动在其生命周期里有4种状态。" class="headerlink" title="每个活动在其生命周期里有4种状态。"></a>每个活动在其生命周期里有4种状态。</h3><ol><li>运行状态：当一个活动位于返回栈的栈顶时，这个活动就会处于运行状态。</li><li>暂停状态：当一个活动不在处于栈顶的位置，但仍然可见时，这个活动就进入了暂停状态。比如：后台、点击一个活动弹出弹框。</li><li>停止状态：当一个活动不在处于栈顶的位置，并且完全不可见时，就进入了停止状态。<br>4.销毁状态：当一个活动从返回栈移除后就变成了销毁状态</li></ol><h2 id="3-活动的生命周期"><a href="#3-活动的生命周期" class="headerlink" title="3.活动的生命周期"></a>3.活动的生命周期</h2><h3 id="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"><a href="#Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。" class="headerlink" title="Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。"></a>Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。</h3><h5 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h5><p>它在活动第一次被创建时调用，表示活动正在被创建，应该在这个方法中完成活动的初始化的操作。比如：setContentVie()加载布局、初始化Activity数据、绑定事件。</p><h5 id="2-onStart（）"><a href="#2-onStart（）" class="headerlink" title="2.onStart（）"></a>2.onStart（）</h5><p>这个方法在活动由不可见变为可见时调用，表示活动正在被启动，即将开始，其实这个时候我们通常都认为活动已经可见了，但是含没有在前台出现，所以我们看不见。</p><h5 id="3-onResume（）"><a href="#3-onResume（）" class="headerlink" title="3.onResume（）"></a>3.onResume（）</h5><p>这个方法在活动准备和用户进行交互时调用，表示Activity已经可以看见了 ，即：出现在前台，并开始活动了。</p><h5 id="4-onPause"><a href="#4-onPause" class="headerlink" title="4.onPause()"></a>4.onPause()</h5><p>这个方法在系统准备去启动或者恢复另一个活动的时候调用，表示活动正在停止过程中。这个方法紧接着就是onStop()方法，但是特殊情况下，如果这个时候我们快速的回到当前的Activity，那么onResume就会被调用，这种情况属于极端情况，一般情况下很难出现。这个时候可以做一些<strong>数据存储</strong>、<strong>停止动画等工作</strong>，但是不能太耗时，太耗时会影响Activity的显示。</p><h5 id="5-onStop"><a href="#5-onStop" class="headerlink" title="5.onStop"></a>5.onStop</h5><p>这个方法在活动完全不可见时调用。表示Activity即将停止。这个时候我们可以做些稍微重量级的工作，但是又不能太耗时。</p><h5 id="6-onRestart（）"><a href="#6-onRestart（）" class="headerlink" title="6.onRestart（）"></a>6.onRestart（）</h5><p>这个方法在活动由停止状态变成运行状态时调用，表示活动正在重新被启动。</p><h5 id="7-onDestroy"><a href="#7-onDestroy" class="headerlink" title="7.onDestroy()"></a>7.onDestroy()</h5><p>这个方法在活动被销毁之前调用，表示Activity即将被销毁，之后活动就将变成销毁状态。这是Activity生命周期中最后一个回调方法，在这里我们可以做一些<strong>回收工作</strong>和<strong>最终的资源释放</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/11542292-f156f9863d8994ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："><a href="#针对上图这里附加几个常见情况的Activity的生命周期的回调流程：" class="headerlink" title="针对上图这里附加几个常见情况的Activity的生命周期的回调流程："></a>针对上图这里附加几个常见情况的Activity的生命周期的回调流程：</h5><ol><li>针对一个特定的Activity的第一次启动：回调流程：onCreate -&gt; onStart -&gt; onResume</li><li>当用户打开新的Activity或者切换到桌面的时候，.回调流程：onPause -&gt; onStop</li><li>当从Activity(A)跳转到Activity(B)时，回调流程：onPause(A) -&gt; onCreate(B) -&gt; onStart(B) -&gt; onResume(B) -&gt; onStop(A)</li><li>当用户回到原来的Activity时：回调流程：onRestart -&gt; onStart -&gt; onResume</li><li>当用户按back键回退时，回调流程：onPause -&gt; onStop -&gt; onDestory</li></ol><h2 id="4-活动的生存期"><a href="#4-活动的生存期" class="headerlink" title="4.活动的生存期"></a>4.活动的生存期</h2><p>1.完整生存期：活动的创建和销毁：onCreate（）和 onDestroy（）<br>2.可见生存期：活动是否可见：onStart（） 和 onStop（）<br>3.前台生存期：活动是否在前台：onResume（） 和 onPause（）</p><p><img src="media/15519727864455/15519766712395.jpg" alt></p><blockquote><p>问题1:onStart()、onStop() 与 onResume()、onPause()的区别。</p></blockquote><p>这两对生命回调方法看起来差不多，在使用时我们甚至可以只保留一对。他们唯一的不同就是：<br>onStart()、onStop()是从<strong>是否可见</strong>这个角度回调的；onResume()、onPause()是从<strong>是否位于前台</strong>这个角度回调的。</p><blockquote><p>问题2: 假设从ActivityA跳到ActivityB中去，那么ActivityB的onResume回调和ActivityA的onPause回调那个会先执行。</p></blockquote><p>这个问题我们要从Activity的启动流程的源码开始解释了。Activity启动过程的源码非常复杂，主要涉及了<strong>Instrumentation</strong>、<strong>ActivityThread</strong>(Android的主线程)和<strong>ActivityManagerService</strong>(AMS)。简单理解就是：启动一个Activity的请求会由Instrumentation来处理，然后将它通过Binder向AMS发送请求，AMS内部维护着一个ActivityStack(活动栈),并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期的调用。<br>源码这里我就不粘贴出来了，直接上流程吧：</p><ol><li>首先我们看到的是ActivityStack中的resumeTopActivityInnerLocked方法将栈顶的Activity先onPause,然后新Activity才能准备启动</li><li>ActivityStackSupervisor中的realStartActivityLocked()方法中调用app.thread.scheduleLaunchActivity方法，因为app.thread是主线程ActivityThread中的ApplicationThrea的一个实现，所以这个方法实在ActivityThread(主线程)中实现的。</li><li>scheduleLaunchActivity方法会在ActivityThread中调用handleLaunchActivity方法执行onCreate、onStart、onResume回调。</li><li>在handleLaunchActivity方法中会先执行performLaunchActivity方法创建一个Activity，同时调用onCreate和onStart。然后handleResumeActivity方法会执行新建的Activity的onResume回调。</li></ol><h2 id="5-onSaveInstanceState和onRestoreInstanceState"><a href="#5-onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="5.onSaveInstanceState和onRestoreInstanceState"></a>5.onSaveInstanceState和onRestoreInstanceState</h2><p>a.出现时机：Activity异常终止时<br>b.系统异常终止时，调用onSavaInstanceState来保存状态。该方法在onStop之前调用，但和onPause没有时序关系。<br>c.Activity被重新创建时，调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。</p><blockquote><p>onSaveInstanceState与onPause的区别：前者适用于对临时性状态的保存，而后者适用于对数据的持久化保存。</p></blockquote><blockquote><p>可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。<strong>谷歌推荐使用onRestoreInstanceState进行数据恢复</strong>。</p></blockquote><h2 id="6-异常情况下的生命周期分析"><a href="#6-异常情况下的生命周期分析" class="headerlink" title="6. 异常情况下的生命周期分析"></a>6. 异常情况下的生命周期分析</h2><h3 id="1）-资源相关系统配置发生改变导致Activity被杀死重新创建"><a href="#1）-资源相关系统配置发生改变导致Activity被杀死重新创建" class="headerlink" title="1）.资源相关系统配置发生改变导致Activity被杀死重新创建"></a>1）.资源相关系统配置发生改变导致Activity被杀死重新创建</h3><p><img src="media/15519727864455/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"><br>当系统配置发生改变之后，Activity会被销毁，其onPause、onStop、onDestory都会被调用，同时由于Activity是在异常情况下终止的，系统会调用<strong>onSaveInstanceState</strong>来保存当前Activity的状态(onSaveInstanceState调用实在onStop之前的，他和onPause没有固定的顺序关系，既可能在他前面也可能会在他后面)。当Activity被重新创建后，系统会调用<strong>onRestoreInstanceState</strong>方法，并把Activity销毁时<strong>onSaveInstanceState</strong>方法保存的<strong>Bundle对象</strong>作为<strong>参数</strong>同时传给<strong>onRestoreInstanceState方法和onCreate方法</strong>。但要注意onRestoreInstanceState在onStart之后调用。</p><blockquote><p>为了避免由于配置的改变导致Activity重建。可以在AndroidManifest.xml中对应的Activity中设置<code>android:configChanges</code>,然后重写onConfigurationChanged方法。 例如：<br><code>android:configChanges=&quot;orientation|screenSize&quot;</code>,这样在屏幕旋转时Activity就不会被杀死重建了，只会调用onConfigurationChanged方法。</p></blockquote><h3 id="2）-资源内存不足导致优先级较低的Activity被杀死"><a href="#2）-资源内存不足导致优先级较低的Activity被杀死" class="headerlink" title="2）.资源内存不足导致优先级较低的Activity被杀死"></a>2）.资源内存不足导致优先级较低的Activity被杀死</h3><h4 id="Activity的优先级由高到低可以分为如下："><a href="#Activity的优先级由高到低可以分为如下：" class="headerlink" title="Activity的优先级由高到低可以分为如下："></a>Activity的优先级由高到低可以分为如下：</h4><ol><li>前台Activity——正在和用户交互的Activity，优先级最高。</li><li>可见但非前台Activity—比如弹出一个弹窗，导致Activity仍可见但是无法和用户交互。</li><li>后台Activity-已经被暂停的Activity，比如执行了onStop，优先级最低</li></ol><p><strong>当系统内存不足时就会按照上面的优先级从低到高杀掉Activity所在的进程</strong><br><strong>若一个进程没有任意一个四大组件进行，进程也会被很快杀掉</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/07/hello-world/"/>
      <url>/2019/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
